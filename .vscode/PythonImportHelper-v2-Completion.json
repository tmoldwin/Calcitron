[
    {
        "label": "constraint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "constraint",
        "description": "constraint",
        "detail": "constraint",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "cm",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "calcitron",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "calcitron",
        "description": "calcitron",
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "importPath": "calcitron",
        "description": "calcitron",
        "isExtraImport": true,
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "Calcitron_functions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Calcitron_functions",
        "description": "Calcitron_functions",
        "detail": "Calcitron_functions",
        "documentation": {}
    },
    {
        "label": "creating_colormap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "creating_colormap",
        "description": "creating_colormap",
        "detail": "creating_colormap",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "matplotlib.colors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "LogNorm",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "SymLogNorm",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "ListedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "ListedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "ListedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "ListedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "ListedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "SymLogNorm",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "ListedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "functions_for_calcitron",
        "importPath": "Old",
        "description": "Old",
        "isExtraImport": true,
        "detail": "Old",
        "documentation": {}
    },
    {
        "label": "functions_from_Demystifying_Calcium",
        "importPath": "Old",
        "description": "Old",
        "isExtraImport": true,
        "detail": "Old",
        "documentation": {}
    },
    {
        "label": "functions_from_Demystifying_Calcium",
        "importPath": "Old",
        "description": "Old",
        "isExtraImport": true,
        "detail": "Old",
        "documentation": {}
    },
    {
        "label": "random",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "random",
        "importPath": "scipy.sparse",
        "description": "scipy.sparse",
        "isExtraImport": true,
        "detail": "scipy.sparse",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Perceptron_Calcitron",
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "isExtraImport": true,
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "plasticity_rule",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Region",
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "isExtraImport": true,
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "constants",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "constants",
        "description": "constants",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.gridspec",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "GridSpec",
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "isExtraImport": true,
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "GridSpec",
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "isExtraImport": true,
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "GridSpec",
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "isExtraImport": true,
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "GridSpec",
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "isExtraImport": true,
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "GridSpec",
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "isExtraImport": true,
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "six",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "six",
        "description": "six",
        "detail": "six",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "supervisors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "supervisors",
        "description": "supervisors",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "one_shot_flip_flop_supervisor",
        "importPath": "supervisors",
        "description": "supervisors",
        "isExtraImport": true,
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "target_perceptron_supervisor",
        "importPath": "supervisors",
        "description": "supervisors",
        "isExtraImport": true,
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "critic_perceptron_supervisor",
        "importPath": "supervisors",
        "description": "supervisors",
        "isExtraImport": true,
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "plot_helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plot_helpers",
        "description": "plot_helpers",
        "detail": "plot_helpers",
        "documentation": {}
    },
    {
        "label": "param_helpers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "param_helpers",
        "description": "param_helpers",
        "detail": "param_helpers",
        "documentation": {}
    },
    {
        "label": "gaussian_filter",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "maximum_filter",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "gaussian_filter",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "jit",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "prange",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Locator",
        "importPath": "matplotlib.ticker",
        "description": "matplotlib.ticker",
        "isExtraImport": true,
        "detail": "matplotlib.ticker",
        "documentation": {}
    },
    {
        "label": "rule_comparison_grid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rule_comparison_grid",
        "description": "rule_comparison_grid",
        "detail": "rule_comparison_grid",
        "documentation": {}
    },
    {
        "label": "example_find_peaks",
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "isExtraImport": true,
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "compute_distance_grid",
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "isExtraImport": true,
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "find_peaks",
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "isExtraImport": true,
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "calcium_barplot",
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "isExtraImport": true,
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "calcium_barplot",
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "isExtraImport": true,
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "calcium_barplot",
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "isExtraImport": true,
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "calcium_barplot",
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "isExtraImport": true,
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "calcium_barplot",
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "isExtraImport": true,
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "choice",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "choice",
        "importPath": "numpy.random",
        "description": "numpy.random",
        "isExtraImport": true,
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "pattern_generators",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "signal_noise_gen",
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "isExtraImport": true,
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "pattern_gen",
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "isExtraImport": true,
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "optuna",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optuna",
        "description": "optuna",
        "detail": "optuna",
        "documentation": {}
    },
    {
        "label": "Exp_Params",
        "importPath": "percep_perform",
        "description": "percep_perform",
        "isExtraImport": true,
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "run_multiple_trials",
        "importPath": "percep_perform",
        "description": "percep_perform",
        "isExtraImport": true,
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "ClassifierMixin",
        "importPath": "sklearn.base",
        "description": "sklearn.base",
        "isExtraImport": true,
        "detail": "sklearn.base",
        "documentation": {}
    },
    {
        "label": "matplotlib.transforms",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.transforms",
        "description": "matplotlib.transforms",
        "detail": "matplotlib.transforms",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "our_constraint1",
        "kind": 2,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "def our_constraint1(alpha, gamma, delta,theta_ppnz , theta_p, theta_d, F_p, F_d):\n    if F_p>F_d and theta_p>theta_d and theta_ppnz>theta_p \\\n            and alpha * F_p < theta_d and (gamma + delta) < theta_d \\\n            and theta_d < (alpha * F_d + gamma) < (alpha * F_p + gamma) < theta_p \\\n            and theta_p < (alpha * F_d + delta) < (alpha * F_p + delta) < theta_ppnz \\\n            and theta_ppnz < (alpha * F_d + gamma + delta) < (alpha * F_p + gamma + delta) \\\n            and 1 == 1:\n        return True\nproblem.addConstraint(our_constraint1, ['alpha', 'gamma', 'delta', 'theta_ppnz', 'theta_p', 'theta_d', 'F_p', 'F_d'])\nsolutions = problem.getSolutions()",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "problem",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "problem = constraint.Problem()\nproblem.addVariable('alpha', np.arange(0.1,1,0.1))\nproblem.addVariable('gamma', np.arange(0.1,1,0.1))\nproblem.addVariable('delta', np.arange(0.1,1,0.1))\nproblem.addVariable('theta_ppnz', [0.8])\nproblem.addVariable('theta_p', [0.6])\nproblem.addVariable('theta_d', [0.5])\nproblem.addVariable('F_p', np.arange(0.1,1,0.1))\nproblem.addVariable('F_d', np.arange(0.1,1,0.1))\ndef our_constraint1(alpha, gamma, delta,theta_ppnz , theta_p, theta_d, F_p, F_d):",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "solutions",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "solutions = problem.getSolutions()\n# Easier way to  and see all solutions\nfor solution in solutions:\n    (solution)\n# Prettier way to  and see all solutions\nlength = len(solutions)\n(length)\n# (\"('alpha','gamma' 'delta', 'theta_ppnz' , 'theta_p', 'theta_d', 'F_p', 'F_d') ∈ {\", end=\"\")\n# for index, solution in enumerate(solutions):\n#     if index == length - 1:",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "length",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "length = len(solutions)\n(length)\n# (\"('alpha','gamma' 'delta', 'theta_ppnz' , 'theta_p', 'theta_d', 'F_p', 'F_d') ∈ {\", end=\"\")\n# for index, solution in enumerate(solutions):\n#     if index == length - 1:\n#         (\"({},{},{},{},{})\".format(round(solution['alpha'], 1),round(solution['delta'],1), round(solution['theta_d'],1)\n#                                      , round(solution['theta_p'],1), round(solution['eta'],1), round(solution['r'], 1)), end=\"\\n\")\n#     else:\n#         (\"({},{},{},{},{}),\".format(round(solution['alpha'],1), round(solution['delta'],1), round(solution['theta_d'],1)\n#                                       , round(solution['theta_p'],1), round(solution['eta'],1), round(solution['r'], 1)), end=\"\\n\")",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "param_dict_bar",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "param_dict_bar = {'alpha':0.6,'gamma':0.1, 'delta':0.3, 'F_p':0.8, 'F_d':0.7}\nx=['alpha', 'gamma', 'delta', 'F_p', 'F_d', 'theta_d', 'theta_p', 'theta_ppnz']\ny = [0.6, 0.1, 0.3, 0.8, 0.7, 0.5, 0.6, 0.8]\nx_bar = [\"local\", \"BAP\", \"supervisor\", \"BAP + supervisor\",  \"local+BAP\", \"local+supervisor\", \"local+BAP+supervisor\"]\nalpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,1,1,0,1])\ndelta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "y = [0.6, 0.1, 0.3, 0.8, 0.7, 0.5, 0.6, 0.8]\nx_bar = [\"local\", \"BAP\", \"supervisor\", \"BAP + supervisor\",  \"local+BAP\", \"local+supervisor\", \"local+BAP+supervisor\"]\nalpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,1,1,0,1])\ndelta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "x_bar",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "x_bar = [\"local\", \"BAP\", \"supervisor\", \"BAP + supervisor\",  \"local+BAP\", \"local+supervisor\", \"local+BAP+supervisor\"]\nalpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,1,1,0,1])\ndelta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "alpha_F_d_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "alpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,1,1,0,1])\ndelta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "alpha_F_p_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "alpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,1,1,0,1])\ndelta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "gamma_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "gamma_vector = np.array([0,1,0,1,1,0,1])\ndelta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "delta_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "delta_vector = np.array([0,0,1,1,0,1,1])\ny_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\",label = r'$\\gamma$')",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "y_Fd",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "y_Fd = param_dict_bar['alpha']*param_dict_bar['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\",label = r'$\\gamma$')\nplt.bar(x_bar,y_delta, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = r'$\\delta$')",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "y_Fp",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "y_Fp = param_dict_bar['alpha']*param_dict_bar['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\",label = r'$\\gamma$')\nplt.bar(x_bar,y_delta, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = r'$\\delta$')\nplt.axhline(0.8, color = \"k\", linestyle = \":\")",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "delta_FP_FD",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "delta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\",label = r'$\\gamma$')\nplt.bar(x_bar,y_delta, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = r'$\\delta$')\nplt.axhline(0.8, color = \"k\", linestyle = \":\")\nplt.axhline(0.6, color = \"k\", linestyle = \":\")",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "y_gamma",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "y_gamma = param_dict_bar['gamma']*gamma_vector\ny_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\",label = r'$\\gamma$')\nplt.bar(x_bar,y_delta, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = r'$\\delta$')\nplt.axhline(0.8, color = \"k\", linestyle = \":\")\nplt.axhline(0.6, color = \"k\", linestyle = \":\")\nplt.axhline(0.5, color = \"k\", linestyle = \":\")",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "y_delta",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP",
        "description": "Old.Calcitron_perceptron_CSP",
        "peekOfCode": "y_delta = param_dict_bar['delta']*delta_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\",label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\",label = r'$\\gamma$')\nplt.bar(x_bar,y_delta, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = r'$\\delta$')\nplt.axhline(0.8, color = \"k\", linestyle = \":\")\nplt.axhline(0.6, color = \"k\", linestyle = \":\")\nplt.axhline(0.5, color = \"k\", linestyle = \":\")\nplt.legend()",
        "detail": "Old.Calcitron_perceptron_CSP",
        "documentation": {}
    },
    {
        "label": "our_constraint2",
        "kind": 2,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "def our_constraint2(alpha, gamma, Z_d, Z_p, theta_p, theta_d, F_p, F_d):\n    if F_p>F_d and theta_p>theta_d \\\n            and alpha * F_p < theta_d and Z_d<Z_p<theta_d\\\n            and theta_d < (alpha * F_d + Z_d) < (alpha * F_p + Z_d) < theta_p \\\n            and theta_p < (alpha * F_d + Z_p) < (alpha * F_p + Z_p):\n        return True\nproblem.addConstraint(our_constraint2, ['alpha', 'gamma', 'Z_d', 'Z_p', 'theta_p', 'theta_d', 'F_p', 'F_d'])\nsolutions = problem.getSolutions()\n# iter = problem.getSolutionIter()\n# (next(iter))",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "problem",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "problem = constraint.Problem()\nproblem.addVariable('alpha', np.arange(0.1,1,0.1))\nproblem.addVariable('gamma', [0])\nproblem.addVariable('Z_d', np.arange(0.1,1,0.1))\nproblem.addVariable('Z_p', np.arange(0.1,1,0.1))\nproblem.addVariable('theta_p', np.arange(0.1,1,0.1))\nproblem.addVariable('theta_d', np.arange(0.1,1,0.1))\nproblem.addVariable('F_p', [0.9])\nproblem.addVariable('F_d', [0.7])\n# def our_constraint1(alpha, gamma, Z_d, Z_p, theta_p, theta_d, F_p, F_d):",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "solutions",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "solutions = problem.getSolutions()\n# iter = problem.getSolutionIter()\n# (next(iter))\n#Easier way to  and see all solutions\nfor solution in solutions:\n    (solution)\n#Prettier way to  and see all solutions\n# length = len(solutions)\n# (length)\n# (\"('alpha','gamma' 'delta', 'theta_ppnz' , 'theta_p', 'theta_d', 'F_p', 'F_d') ∈ {\", end=\"\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "param_dict_bar2",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "param_dict_bar2 = {'F_d': 0.7, 'F_p': 0.9, 'gamma': 0, 'Z_d': 0.2, 'Z_p': 0.5, 'alpha': 0.6, 'theta_d': 0.6, 'theta_p': 0.9}\n# x=['alpha', 'gamma', 'Z_d', 'Z_p', 'F_p', 'F_d', 'theta_d', 'theta_p']\n# y = [0.3, 0.1, 0.2, 0.4, 0.9, 0.7, 0.5, 0.6]\nx_bar = [\"local\", \"BAP\", \"false-positive \\n supervisor\",\"false-negative \\n supervisor\", \"local+BAP\", \"local+BAP+false- \\n positive supervisor\", \"local+false- \\n negative supervisor\"]\nalpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,0,1,1,0])\nZd_vector = np.array([0,0,1,0,0,1,0])\nZp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "x_bar",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "x_bar = [\"local\", \"BAP\", \"false-positive \\n supervisor\",\"false-negative \\n supervisor\", \"local+BAP\", \"local+BAP+false- \\n positive supervisor\", \"local+false- \\n negative supervisor\"]\nalpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,0,1,1,0])\nZd_vector = np.array([0,0,1,0,0,1,0])\nZp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "alpha_F_d_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "alpha_F_d_vector = np.array([1,0,0,0,1,1,1])\nalpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,0,1,1,0])\nZd_vector = np.array([0,0,1,0,0,1,0])\nZp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "alpha_F_p_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "alpha_F_p_vector = np.array([1,0,0,0,1,1,1])\ngamma_vector = np.array([0,1,0,0,1,1,0])\nZd_vector = np.array([0,0,1,0,0,1,0])\nZp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "gamma_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "gamma_vector = np.array([0,1,0,0,1,1,0])\nZd_vector = np.array([0,0,1,0,0,1,0])\nZp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "Zd_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "Zd_vector = np.array([0,0,1,0,0,1,0])\nZp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "Zp_vector",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "Zp_vector = np.array([0,0,0,1,0,0,1])\ny_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "y_Fd",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "y_Fd = param_dict_bar2['alpha']*param_dict_bar2['F_d']*alpha_F_d_vector\ny_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\", label = r'$\\gamma$')",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "y_Fp",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "y_Fp = param_dict_bar2['alpha']*param_dict_bar2['F_p']*alpha_F_p_vector\ndelta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\", label = r'$\\gamma$')\nplt.bar(x_bar,y_Zd, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = \"Z_d\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "delta_FP_FD",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "delta_FP_FD = y_Fp - y_Fd\ny_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\", label = r'$\\gamma$')\nplt.bar(x_bar,y_Zd, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = \"Z_d\")\nplt.bar(x_bar,y_Zp, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"limegreen\", label = \"Z_p\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "y_gamma",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "y_gamma = param_dict_bar2['gamma']*gamma_vector\ny_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\", label = r'$\\gamma$')\nplt.bar(x_bar,y_Zd, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = \"Z_d\")\nplt.bar(x_bar,y_Zp, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"limegreen\", label = \"Z_p\")\nplt.axhline(param_dict_bar2['theta_d'], color = \"k\", linestyle = \":\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "y_Zd",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "y_Zd = param_dict_bar2['Z_d']*Zd_vector\ny_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\", label = r'$\\gamma$')\nplt.bar(x_bar,y_Zd, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = \"Z_d\")\nplt.bar(x_bar,y_Zp, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"limegreen\", label = \"Z_p\")\nplt.axhline(param_dict_bar2['theta_d'], color = \"k\", linestyle = \":\")\nplt.axhline(param_dict_bar2['theta_p'], color = \"k\", linestyle = \":\")",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "y_Zp",
        "kind": 5,
        "importPath": "Old.Calcitron_perceptron_CSP_2",
        "description": "Old.Calcitron_perceptron_CSP_2",
        "peekOfCode": "y_Zp = param_dict_bar2['Z_p']*Zp_vector\nplt.figure(1)\nplt.bar(x_bar,y_Fd, color = \"tab:orange\", label = r'$\\alpha$' + \"*F_d\")\nplt.bar(x_bar,delta_FP_FD , bottom= y_Fd,color = \"r\", label = r'$\\alpha$' + \"*F_p\")\nplt.bar(x_bar,y_gamma, bottom=y_Fd+delta_FP_FD, color = \"b\", label = r'$\\gamma$')\nplt.bar(x_bar,y_Zd, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"g\", label = \"Z_d\")\nplt.bar(x_bar,y_Zp, bottom = y_Fd+delta_FP_FD+y_gamma, color = \"limegreen\", label = \"Z_p\")\nplt.axhline(param_dict_bar2['theta_d'], color = \"k\", linestyle = \":\")\nplt.axhline(param_dict_bar2['theta_p'], color = \"k\", linestyle = \":\")\nplt.xticks(rotation=15)",
        "detail": "Old.Calcitron_perceptron_CSP_2",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "P = 25\nn_synapses = 100\nX = np.ones((P, n_synapses))\nZ = np.zeros(P)\nZ[2] = 0.6\nZ_0 = np.zeros(P)\nW_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "n_synapses",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "n_synapses = 100\nX = np.ones((P, n_synapses))\nZ = np.zeros(P)\nZ[2] = 0.6\nZ_0 = np.zeros(P)\nW_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "X = np.ones((P, n_synapses))\nZ = np.zeros(P)\nZ[2] = 0.6\nZ_0 = np.zeros(P)\nW_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "Z = np.zeros(P)\nZ[2] = 0.6\nZ_0 = np.zeros(P)\nW_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "Z[2]",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "Z[2] = 0.6\nZ_0 = np.zeros(P)\nW_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "Z_0",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "Z_0 = np.zeros(P)\nW_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "W_0",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "W_0 = np.linspace(0, 5.5, n_synapses)\ncalc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])\ncmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "calc0",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "calc0 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])\ncmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),\n                                                             (0.3,'red'),(1, '#760404')])",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "calc1",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "calc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])\ncmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),\n                                                             (0.3,'red'),(1, '#760404')])\n# cmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.08, 'yellow'),",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "calc1.weights",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "calc1.weights = np.array(W_0)\ncalc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])\ncmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),\n                                                             (0.3,'red'),(1, '#760404')])\n# cmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.08, 'yellow'),\n#                                                     (0.1, 'orange'), (0.25, 'red'),",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "calc0.weights",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "calc0.weights = np.array(W_0)\nfig_overtime, axes_graphs = plt.subplots(3,2, figsize = (7,8))\ncmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])\ncmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),\n                                                             (0.3,'red'),(1, '#760404')])\n# cmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.08, 'yellow'),\n#                                                     (0.1, 'orange'), (0.25, 'red'),\n#                                                     (0.8, '#760404'), (1, 'black')])",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "cmap0",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "cmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.09, 'yellow'),\n                                                    (0.17, 'orange'),\n                                                    (1, '#760404')])\ncmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),\n                                                             (0.3,'red'),(1, '#760404')])\n# cmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.08, 'yellow'),\n#                                                     (0.1, 'orange'), (0.25, 'red'),\n#                                                     (0.8, '#760404'), (1, 'black')])\ndelta_cmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'blue'),\n                                                    (0.1, 'white'),",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "cmap1",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "cmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.04, 'yellow'),(0.12, 'orange'),\n                                                             (0.3,'red'),(1, '#760404')])\n# cmap1 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'white'), (0.08, 'yellow'),\n#                                                     (0.1, 'orange'), (0.25, 'red'),\n#                                                     (0.8, '#760404'), (1, 'black')])\ndelta_cmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'blue'),\n                                                    (0.1, 'white'),\n                                                    (1, 'red')])\nfor prot in [0]:\n    calc0.train(X, Z_0, protocol=prot, eta=0.5, hard_threshold=0, k=0.25)",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "delta_cmap0",
        "kind": 5,
        "importPath": "Old.constant_calcium_over_time",
        "description": "Old.constant_calcium_over_time",
        "peekOfCode": "delta_cmap0 = mcolors.LinearSegmentedColormap.from_list('mycmap', [(0, 'blue'),\n                                                    (0.1, 'white'),\n                                                    (1, 'red')])\nfor prot in [0]:\n    calc0.train(X, Z_0, protocol=prot, eta=0.5, hard_threshold=0, k=0.25)\n    # colormap0 = cm.LinearColormap(theta_colors=['blue', 'white', 'red'], index=[np.amin(calc0.delta_w), 0, np.amax(calc0.delta_w)]\n    #                               , vmin=np.amin(calc0.delta_w),\n    #                              vmax=np.amax(calc0.delta_w))\n    offset0 = mcolors.TwoSlopeNorm(vmin=np.amin(calc0.delta_w),vcenter=0., vmax=np.amax(calc0.delta_w))\n    #plot_data, asym_cmap0 = cc.asymmetric_cmap(calc0.delta_w, cmap, ref_point=0)[:2]",
        "detail": "Old.constant_calcium_over_time",
        "documentation": {}
    },
    {
        "label": "Critic_Perceptron_Calcitron",
        "kind": 6,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "class Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)\n        self.Z_p = Z_p\n        self.Z_d = Z_d\n        self.name = \"critic perceptron\"\n        #added Z_p and Z_d to the class so can use in the next functions\n    def calculate_Z_critic(self, Z_i, y_hat_binary_i):\n        if y_hat_binary_i == 1 and Z_i == 0: #false positive\n            return self.Z_d",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "eta = 0.000005\n#eta = 0.00001 - for N=300 and P = 550\nparam_dict_bar2 = {'F_d': 0.7, 'F_p': 0.9, 'gamma': 0, 'Z_d': 0.2, 'Z_p': 0.5, 'alpha': 0.6, 'theta_d': 0.6,\n                       'theta_p': 0.9}\ntheta_d_algo2 = 0.6\ntheta_p_algo2 = 0.9\neta_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0, (theta_d_algo2,theta_p_algo2):eta,\n                (theta_p_algo2,np.inf):eta}\nFP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "#eta",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "#eta = 0.00001 - for N=300 and P = 550\nparam_dict_bar2 = {'F_d': 0.7, 'F_p': 0.9, 'gamma': 0, 'Z_d': 0.2, 'Z_p': 0.5, 'alpha': 0.6, 'theta_d': 0.6,\n                       'theta_p': 0.9}\ntheta_d_algo2 = 0.6\ntheta_p_algo2 = 0.9\neta_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0, (theta_d_algo2,theta_p_algo2):eta,\n                (theta_p_algo2,np.inf):eta}\nFP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "param_dict_bar2",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "param_dict_bar2 = {'F_d': 0.7, 'F_p': 0.9, 'gamma': 0, 'Z_d': 0.2, 'Z_p': 0.5, 'alpha': 0.6, 'theta_d': 0.6,\n                       'theta_p': 0.9}\ntheta_d_algo2 = 0.6\ntheta_p_algo2 = 0.9\neta_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0, (theta_d_algo2,theta_p_algo2):eta,\n                (theta_p_algo2,np.inf):eta}\nFP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "theta_d_algo2",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "theta_d_algo2 = 0.6\ntheta_p_algo2 = 0.9\neta_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0, (theta_d_algo2,theta_p_algo2):eta,\n                (theta_p_algo2,np.inf):eta}\nFP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "theta_p_algo2",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "theta_p_algo2 = 0.9\neta_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0, (theta_d_algo2,theta_p_algo2):eta,\n                (theta_p_algo2,np.inf):eta}\nFP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "eta_dict_SBC_algo2",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "eta_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0, (theta_d_algo2,theta_p_algo2):eta,\n                (theta_p_algo2,np.inf):eta}\nFP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)\n        self.Z_p = Z_p",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "FP_dict_SBC_algo2",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "FP_dict_SBC_algo2 = {(-np.inf,theta_d_algo2):0.25, (theta_d_algo2,theta_p_algo2):0.7, (theta_p_algo2,np.inf):0.9}\nperceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)\n        self.Z_p = Z_p\n        self.Z_d = Z_d\n        self.name = \"critic perceptron\"",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "perceptron_param_dict_for_generic_sbc",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "perceptron_param_dict_for_generic_sbc = {\"eta_dict\":eta_dict_SBC_algo2, \"FP_dict\":FP_dict_SBC_algo2,\"soft_threshold\": 0}\nf_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)\n        self.Z_p = Z_p\n        self.Z_d = Z_d\n        self.name = \"critic perceptron\"\n        #added Z_p and Z_d to the class so can use in the next functions",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "f_d",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "f_d = FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2]\nf_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)\n        self.Z_p = Z_p\n        self.Z_d = Z_d\n        self.name = \"critic perceptron\"\n        #added Z_p and Z_d to the class so can use in the next functions\n    def calculate_Z_critic(self, Z_i, y_hat_binary_i):",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "f_p",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "f_p = FP_dict_SBC_algo2[theta_p_algo2,np.inf]\nclass Critic_Perceptron_Calcitron(Perceptron_Calcitron):\n    def __init__(self, alpha, beta, gamma, delta, N, Z_p, Z_d, b=0):\n        super().__init__(alpha, beta, gamma, delta, N, b)\n        self.Z_p = Z_p\n        self.Z_d = Z_d\n        self.name = \"critic perceptron\"\n        #added Z_p and Z_d to the class so can use in the next functions\n    def calculate_Z_critic(self, Z_i, y_hat_binary_i):\n        if y_hat_binary_i == 1 and Z_i == 0: #false positive",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "#N",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "#N = 200 #num of synapses\n#P = 550 #num of patterns\n#X = np.array([np.ceil(rand(1,N, sparsity).A).flatten() for num in range(P)])\n# Z = np.squeeze(np.ceil(rand(1,P,sparsity).A)) #target\n# bias_for_algo2 = -0.5*((N*sparsity*FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2])+\n#                       (N*sparsity*FP_dict_SBC_algo2[theta_p_algo2,np.inf]))\n#\n# Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b= bias_for_algo2, Z_p = 0.5, Z_d = 0.2)\n# Calc_training_2.weights = np.array([random.uniform(f_d, f_p) for w in range(N)])\n# Calc_training_2.multiple_epoch_training(10000,X, Z, protocol=fc.modified_shouval_array,",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "#P",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "#P = 550 #num of patterns\n#X = np.array([np.ceil(rand(1,N, sparsity).A).flatten() for num in range(P)])\n# Z = np.squeeze(np.ceil(rand(1,P,sparsity).A)) #target\n# bias_for_algo2 = -0.5*((N*sparsity*FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2])+\n#                       (N*sparsity*FP_dict_SBC_algo2[theta_p_algo2,np.inf]))\n#\n# Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b= bias_for_algo2, Z_p = 0.5, Z_d = 0.2)\n# Calc_training_2.weights = np.array([random.uniform(f_d, f_p) for w in range(N)])\n# Calc_training_2.multiple_epoch_training(10000,X, Z, protocol=fc.modified_shouval_array,\n#                       param_dict=perceptron_param_dict_for_generic_sbc,",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "#X",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "#X = np.array([np.ceil(rand(1,N, sparsity).A).flatten() for num in range(P)])\n# Z = np.squeeze(np.ceil(rand(1,P,sparsity).A)) #target\n# bias_for_algo2 = -0.5*((N*sparsity*FP_dict_SBC_algo2[theta_d_algo2,theta_p_algo2])+\n#                       (N*sparsity*FP_dict_SBC_algo2[theta_p_algo2,np.inf]))\n#\n# Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b= bias_for_algo2, Z_p = 0.5, Z_d = 0.2)\n# Calc_training_2.weights = np.array([random.uniform(f_d, f_p) for w in range(N)])\n# Calc_training_2.multiple_epoch_training(10000,X, Z, protocol=fc.modified_shouval_array,\n#                       param_dict=perceptron_param_dict_for_generic_sbc,\n#                       a1=theta_d_algo2, a2=theta_p_algo2, eta_b = 0)",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "P_list",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "P_list = [100,200,300]\naccuracy_mat_critic = []\nbias_mat_critic = []\nsparsity = 0.5\nN = 100\nfor p in P_list:\n    X = np.array([np.ceil(rand(1, N, sparsity).A).flatten() for num in range(p)])\n    Z = np.squeeze(np.ceil(rand(1, p, sparsity).A))  # target\n    bias_for_algo2 = -0.5 * ((N * sparsity * FP_dict_SBC_algo2[theta_d_algo2, theta_p_algo2]) +\n                             (N * sparsity * FP_dict_SBC_algo2[theta_p_algo2, np.inf]))",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "accuracy_mat_critic",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "accuracy_mat_critic = []\nbias_mat_critic = []\nsparsity = 0.5\nN = 100\nfor p in P_list:\n    X = np.array([np.ceil(rand(1, N, sparsity).A).flatten() for num in range(p)])\n    Z = np.squeeze(np.ceil(rand(1, p, sparsity).A))  # target\n    bias_for_algo2 = -0.5 * ((N * sparsity * FP_dict_SBC_algo2[theta_d_algo2, theta_p_algo2]) +\n                             (N * sparsity * FP_dict_SBC_algo2[theta_p_algo2, np.inf]))\n    Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b=bias_for_algo2, Z_p=0.5, Z_d=0.2)",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "bias_mat_critic",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "bias_mat_critic = []\nsparsity = 0.5\nN = 100\nfor p in P_list:\n    X = np.array([np.ceil(rand(1, N, sparsity).A).flatten() for num in range(p)])\n    Z = np.squeeze(np.ceil(rand(1, p, sparsity).A))  # target\n    bias_for_algo2 = -0.5 * ((N * sparsity * FP_dict_SBC_algo2[theta_d_algo2, theta_p_algo2]) +\n                             (N * sparsity * FP_dict_SBC_algo2[theta_p_algo2, np.inf]))\n    Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b=bias_for_algo2, Z_p=0.5, Z_d=0.2)\n    Calc_training_2.weights = np.array([random.uniform(f_d, f_p) for w in range(N)])",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "sparsity",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "sparsity = 0.5\nN = 100\nfor p in P_list:\n    X = np.array([np.ceil(rand(1, N, sparsity).A).flatten() for num in range(p)])\n    Z = np.squeeze(np.ceil(rand(1, p, sparsity).A))  # target\n    bias_for_algo2 = -0.5 * ((N * sparsity * FP_dict_SBC_algo2[theta_d_algo2, theta_p_algo2]) +\n                             (N * sparsity * FP_dict_SBC_algo2[theta_p_algo2, np.inf]))\n    Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b=bias_for_algo2, Z_p=0.5, Z_d=0.2)\n    Calc_training_2.weights = np.array([random.uniform(f_d, f_p) for w in range(N)])\n    accuracy_per_P_critic, bias_history_per_P_critic = Calc_training_2.multiple_epoch_training(10000, X, Z, protocol=fc.modified_shouval_array,",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Old.Critic_Perceptron_Calcitron",
        "description": "Old.Critic_Perceptron_Calcitron",
        "peekOfCode": "N = 100\nfor p in P_list:\n    X = np.array([np.ceil(rand(1, N, sparsity).A).flatten() for num in range(p)])\n    Z = np.squeeze(np.ceil(rand(1, p, sparsity).A))  # target\n    bias_for_algo2 = -0.5 * ((N * sparsity * FP_dict_SBC_algo2[theta_d_algo2, theta_p_algo2]) +\n                             (N * sparsity * FP_dict_SBC_algo2[theta_p_algo2, np.inf]))\n    Calc_training_2 = Critic_Perceptron_Calcitron(0.45, 0, 0, 1, N, b=bias_for_algo2, Z_p=0.5, Z_d=0.2)\n    Calc_training_2.weights = np.array([random.uniform(f_d, f_p) for w in range(N)])\n    accuracy_per_P_critic, bias_history_per_P_critic = Calc_training_2.multiple_epoch_training(10000, X, Z, protocol=fc.modified_shouval_array,\n                                            param_dict=perceptron_param_dict_for_generic_sbc,",
        "detail": "Old.Critic_Perceptron_Calcitron",
        "documentation": {}
    },
    {
        "label": "calculate_plasticity",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def calculate_plasticity(C, weight, protocol, param_dict, N):\n    delta_w = protocol(C, weight, param_dict,N)\n    return delta_w\n#add soft omega after make it usable all the tme with param dict\ndef step_function(x, dict):\n    (x)\n    for interval in dict.keys():\n        if x >= interval[0] and x < interval[1]:\n            return dict[interval]\ndef modified_shouval_array(Ca,weights, param_dict, N):",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "step_function",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def step_function(x, dict):\n    (x)\n    for interval in dict.keys():\n        if x >= interval[0] and x < interval[1]:\n            return dict[interval]\ndef modified_shouval_array(Ca,weights, param_dict, N):\n    delta_w = np.zeros(N)\n    eta_dict, FP_dict, soft_threshold = \\\n        param_dict[\"eta_dict\"], param_dict[\"FP_dict\"], param_dict[\"soft_threshold\"]\n    for interval in eta_dict.keys():",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "modified_shouval_array",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def modified_shouval_array(Ca,weights, param_dict, N):\n    delta_w = np.zeros(N)\n    eta_dict, FP_dict, soft_threshold = \\\n        param_dict[\"eta_dict\"], param_dict[\"FP_dict\"], param_dict[\"soft_threshold\"]\n    for interval in eta_dict.keys():\n        is_in_interval = np.bitwise_and((np.heaviside(Ca-interval[0], 0)).astype(int) ,(np.heaviside(interval[1]-Ca, 0).astype(int)))\n        is_in_interval_updated = eta_dict[interval]*is_in_interval*(FP_dict[interval] - weights)\n        delta_w += is_in_interval_updated\n    return delta_w\ndef modified_shouval_array_linear(Ca,weights, param_dict, N):",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "modified_shouval_array_linear",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def modified_shouval_array_linear(Ca,weights, param_dict, N):\n    delta_w = np.zeros(N)\n    eta_dict, FP_dict, soft_threshold = \\\n        param_dict[\"eta_dict\"], param_dict[\"FP_dict\"], param_dict[\"soft_threshold\"]\n    for interval in eta_dict.keys():\n        is_in_interval = np.bitwise_and((np.heaviside(Ca-interval[0], 0)).astype(int) ,(np.heaviside(interval[1]-Ca, 0).astype(int)))\n        is_in_interval_updated = eta_dict[interval]*is_in_interval*FP_dict[interval]\n        delta_w += is_in_interval_updated\n    return delta_w\ndef modified_shouval_math(Ca, w, param_dict):",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "modified_shouval_math",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def modified_shouval_math(Ca, w, param_dict):\n    eta_dict, FP_calcium_dict, soft_threshold = \\\n        param_dict[\"eta_dict\"], param_dict[\"FP_calcium_dict\"], param_dict[\"soft_threshold\"]\n    if soft_threshold == 1:\n        return soft_omega(Ca) * (soft_omega(Ca, k=[0.5,0, 1], theta= [0.3, 1.1],b=[100,100,100,100])- w)\n    else:\n        return step_function(Ca, eta_dict) * (step_function(Ca, FP_calcium_dict)- w)\ndef calculate_momentum_update(raw_delta_vec, m,v,beta1 = 0.9,beta2 = 0.999, eps = 1e-8):\n    \"\"\"\n    Momentum calculation - Receives 1xN row of deltas, and instance variables m and v",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "calculate_momentum_update",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def calculate_momentum_update(raw_delta_vec, m,v,beta1 = 0.9,beta2 = 0.999, eps = 1e-8):\n    \"\"\"\n    Momentum calculation - Receives 1xN row of deltas, and instance variables m and v\n    Returns same, make sure to multiply by learning rate outside\n    \"\"\"\n    m = beta1*m + (1-beta1)*raw_delta_vec\n    v = beta2*v + (1-beta2)*(raw_delta_vec**2)\n    momentum_delta_vec = np.squeeze(m/(np.sqrt(v)+eps))#deleted a lr, and a minus for locations, + for bias, - for weights\n    return momentum_delta_vec, m, v\ndef add_colorbar_outside(im,ax):",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "add_colorbar_outside",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def add_colorbar_outside(im,ax):\n    fig = ax.get_figure()\n    bbox = ax.get_position() #bbox contains the [x0 (left), y0 (bottom), x1 (right), y1 (top)] of the axis.\n    width = 0.01\n    eps = 0.01 #margin between plot and colorbar\n    # [left most position, bottom position, width, height] of color bar.\n    cax = fig.add_axes([bbox.x1 + eps, bbox.y0, width, bbox.height])\n    cbar = fig.colorbar(im, cax=cax)\n    return cbar\ndef delta_w_graph(subgraph, col, x_axis, lines_for_plot, theta_d, theta_p):",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "delta_w_graph",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def delta_w_graph(subgraph, col, x_axis, lines_for_plot, theta_d, theta_p):\n    range_of_colors = np.linspace(0, 1, len(lines_for_plot))\n    colors = [mpl.cm.Wistia(x) for x in range_of_colors]\n    for n, color in enumerate(colors):\n        subgraph[col].plot(x_axis, lines_for_plot[n], color=color)\n    subgraph[col].set_xticks([theta_d, theta_p])\n    subgraph[col].set_xticklabels([r'$\\theta_D$', r'$\\theta_P$'])\n    subgraph[col].set_xlabel('$\\mathregular{[Ca^{2+}]}$', fontsize = 15)\ndef delta_w_imshow(subgraph, col, matrix_for_plot, C_range_in_matrix, weight_range_in_matrix, theta_d, theta_p, norm = None):\n    bound = max([abs(np.amin(matrix_for_plot)), abs(np.amax(matrix_for_plot))])",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "delta_w_imshow",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def delta_w_imshow(subgraph, col, matrix_for_plot, C_range_in_matrix, weight_range_in_matrix, theta_d, theta_p, norm = None):\n    bound = max([abs(np.amin(matrix_for_plot)), abs(np.amax(matrix_for_plot))])\n    if norm == None:\n        subgraph[col].imshow(matrix_for_plot, cmap=\"coolwarm\", aspect=\"auto\",\n                  extent=[0, C_range_in_matrix[-1], weight_range_in_matrix[0], weight_range_in_matrix[-1]],\n                  origin=\"lower\", vmin=-bound, vmax=bound)\n        subgraph[col].set_xticks([theta_d, theta_p])\n        subgraph[col].set_xticklabels([r'$\\theta_D$', r'$\\theta_P$'])\n        subgraph[col].set_xlabel('$\\mathregular{[Ca^{2+}]}$', fontsize = 15)\n    else:",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "run_plasticity",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def run_plasticity(C, weight_0, protocol, param_dict, dif_func_list):\n    weight_over_time = np.zeros(len(C))\n    weight_over_time[0] = weight_0\n    for i in range(len(C) - 1):\n        delta_w = calculate_plasticity(C[i], weight_over_time[i], protocol, param_dict, dif_func_list)\n        weight_over_time[i + 1] = weight_over_time[i] + delta_w\n    return weight_over_time\ndef w_graph_one_eta(subgraph, col, C_range_potentiation, C_range_depression, start_weight, protocol, duration,\n                           param_dict, N, dif_func_list=False, no_row_col = False):\n    subgraph[col].plot(range(len(C_range_potentiation)),[calculate_plasticity(C_i, start_weight, protocol,",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "w_graph_one_eta",
        "kind": 2,
        "importPath": "Old.functions_for_calcitron",
        "description": "Old.functions_for_calcitron",
        "peekOfCode": "def w_graph_one_eta(subgraph, col, C_range_potentiation, C_range_depression, start_weight, protocol, duration,\n                           param_dict, N, dif_func_list=False, no_row_col = False):\n    subgraph[col].plot(range(len(C_range_potentiation)),[calculate_plasticity(C_i, start_weight, protocol,\n                                    param_dict,N ) for C_i in C_range_potentiation] ,\"r\")\n    subgraph[col].plot(range(len(C_range_potentiation)), [calculate_plasticity(C_i, start_weight, protocol,\n                                              param_dict, N) for C_i in C_range_depression],\"b\")\n    (\"d\", [calculate_plasticity(C_i, start_weight, protocol,\n                                              param_dict, N) for C_i in C_range_depression])\n    (\"p\", [calculate_plasticity(C_i, start_weight, protocol,\n                                    param_dict,N ) for C_i in C_range_potentiation])",
        "detail": "Old.functions_for_calcitron",
        "documentation": {}
    },
    {
        "label": "omega",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def omega(C, param_dict):\n    k_d, k_p, theta_d, theta_p, b1, b2 = param_dict[\"k_d\"], param_dict[\"k_p\"], param_dict[\"theta_d\"], param_dict[\n        \"theta_p\"], \\\n                                         param_dict[\"b1\"], param_dict[\"b2\"]\n    return -k_d / (1 + np.e ** (-b2 * (C - theta_d))) + (k_d + k_p) / (1 + np.e ** (-b1 * (C - theta_p)))\ndef step_function(x, dict):\n    for interval in dict.keys():\n        if x >= interval[0] and x < interval[1]:\n            return dict[interval]\ndef shouval1(C, w, param_dict):",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "step_function",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def step_function(x, dict):\n    for interval in dict.keys():\n        if x >= interval[0] and x < interval[1]:\n            return dict[interval]\ndef shouval1(C, w, param_dict):\n    hard_threshold = param_dict[\"hard_threshold\"]\n    eta = param_dict[\"eta\"]\n    if hard_threshold == 1:\n        return eta * hard_omega(C, param_dict)\n    elif hard_threshold == 2:",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "shouval1",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def shouval1(C, w, param_dict):\n    hard_threshold = param_dict[\"hard_threshold\"]\n    eta = param_dict[\"eta\"]\n    if hard_threshold == 1:\n        return eta * hard_omega(C, param_dict)\n    elif hard_threshold == 2:\n        return eta * shouval_omega(C, param_dict)\n    else:\n        return eta * omega(C, param_dict)\ndef modified_shouval_math(Ca, w, param_dict):",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "modified_shouval_math",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def modified_shouval_math(Ca, w, param_dict):\n    eta_dict, FP_calcium_dict, soft_threshold = param_dict[\"eta_dict\"], param_dict[\"FP_calcium_dict\"], param_dict[\n        \"soft_threshold\"]\n    if soft_threshold == 1:\n        return soft_omega(Ca, param_dict['p1']) * (soft_omega(Ca, param_dict['p2']) - w)\n    else:\n        return step_function(Ca, eta_dict) * (step_function(Ca, FP_calcium_dict) - w)\ndef modified_shouval_array(Ca, weights, param_dict, N):\n    delta_w = np.zeros(N)\n    eta_dict, FP_dict, soft_threshold = \\",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "modified_shouval_array",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def modified_shouval_array(Ca, weights, param_dict, N):\n    delta_w = np.zeros(N)\n    eta_dict, FP_dict, soft_threshold = \\\n        param_dict[\"eta_dict\"], param_dict[\"FP_dict\"], param_dict[\"soft_threshold\"]\n    for interval in eta_dict.keys():\n        is_in_interval = np.bitwise_and((np.heaviside(Ca - interval[0], 0)).astype(int),\n                                        (np.heaviside(interval[1] - Ca, 0).astype(int)))\n        is_in_interval_updated = eta_dict[interval] * is_in_interval * (FP_dict[interval] - weights)\n        delta_w += is_in_interval_updated\n    return delta_w",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "calculate_plasticity",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def calculate_plasticity(C, weight, protocol, param_dict, dif_func_list, just_protocol = False):\n    if dif_func_list == 1:\n        delta_w = GB_func_list[protocol](C, weight, param_dict)\n    elif just_protocol:\n        delta_w = protocol(C, weight, param_dict)\n    else:\n        delta_w = functions[protocol](C, weight, param_dict)\n    return delta_w\ndef run_plasticity(C, weight_0, protocol, param_dict, dif_func_list, just_protocol = False):\n    weight_over_time = np.zeros(len(C))",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "run_plasticity",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def run_plasticity(C, weight_0, protocol, param_dict, dif_func_list, just_protocol = False):\n    weight_over_time = np.zeros(len(C))\n    weight_over_time[0] = weight_0\n    for i in range(len(C) - 1):\n        delta_w = calculate_plasticity(C[i], weight_over_time[i], protocol, param_dict, dif_func_list, just_protocol=just_protocol)\n        weight_over_time[i + 1] = weight_over_time[i] + delta_w\n    return weight_over_time\ndef w_graph_different_fps(subgraph, loc, C_range_potentiation, C_range_depression, start_weight, fp_min, fp_max, protocol, duration,\n                           param_dict, dif_func_list=False, no_row_col = False, no_fp = 0):\n    if no_row_col == True:",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "w_graph_different_fps",
        "kind": 2,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "def w_graph_different_fps(subgraph, loc, C_range_potentiation, C_range_depression, start_weight, fp_min, fp_max, protocol, duration,\n                           param_dict, dif_func_list=False, no_row_col = False, no_fp = 0):\n    if no_row_col == True:\n        subgraph.plot(range(len(C_range_potentiation)),\n                                cf.run_plasticity(C_range_potentiation, fp_min, protocol,\n                                                  param_dict[protocol], dif_func_list),\n                                \"r\", linestyle=\":\")\n        subgraph.plot(range(len(C_range_potentiation)),\n                                cf.run_plasticity(C_range_potentiation, start_weight, protocol,\n                                                  param_dict[protocol], dif_func_list),",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "functions",
        "kind": 5,
        "importPath": "Old.functions_from_Demystifying_Calcium",
        "description": "Old.functions_from_Demystifying_Calcium",
        "peekOfCode": "functions = [shouval1, modified_shouval_math]\ndef calculate_plasticity(C, weight, protocol, param_dict, dif_func_list, just_protocol = False):\n    if dif_func_list == 1:\n        delta_w = GB_func_list[protocol](C, weight, param_dict)\n    elif just_protocol:\n        delta_w = protocol(C, weight, param_dict)\n    else:\n        delta_w = functions[protocol](C, weight, param_dict)\n    return delta_w\ndef run_plasticity(C, weight_0, protocol, param_dict, dif_func_list, just_protocol = False):",
        "detail": "Old.functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "P = 50\nn_synapses = 10\nW_0 = np.linspace(0, 5.5, n_synapses)\nZ = np.linspace(0,cf.theta_p + 0.2, P)\nX = np.ones((P, n_synapses))\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "n_synapses",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "n_synapses = 10\nW_0 = np.linspace(0, 5.5, n_synapses)\nZ = np.linspace(0,cf.theta_p + 0.2, P)\nX = np.ones((P, n_synapses))\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],\n                        origin=\"lower\")",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "W_0",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "W_0 = np.linspace(0, 5.5, n_synapses)\nZ = np.linspace(0,cf.theta_p + 0.2, P)\nX = np.ones((P, n_synapses))\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],\n                        origin=\"lower\")\nl = plt.ylabel(r'$\\Delta$' + 'w', rotation = 0, labelpad= 10)",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "Z = np.linspace(0,cf.theta_p + 0.2, P)\nX = np.ones((P, n_synapses))\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],\n                        origin=\"lower\")\nl = plt.ylabel(r'$\\Delta$' + 'w', rotation = 0, labelpad= 10)\nplt.xlabel('Ca global')",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "X = np.ones((P, n_synapses))\ncalc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],\n                        origin=\"lower\")\nl = plt.ylabel(r'$\\Delta$' + 'w', rotation = 0, labelpad= 10)\nplt.xlabel('Ca global')\nplt.title('Increasing supervising signal')",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "calc1",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "calc1 = Calcitron(0.2,0,0,1,n_synapses)\ncalc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],\n                        origin=\"lower\")\nl = plt.ylabel(r'$\\Delta$' + 'w', rotation = 0, labelpad= 10)\nplt.xlabel('Ca global')\nplt.title('Increasing supervising signal')\nplt.show()",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "calc1.weights",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "calc1.weights = np.array(W_0)\nfor prot in [0]:\n    calc1.train(X, Z, protocol = prot)\n    plt.imshow(calc1.delta_w.T, cmap=\"coolwarm\", aspect=\"auto\", extent=[0, Z[-1], 0, W_0[-1]],\n                        origin=\"lower\")\nl = plt.ylabel(r'$\\Delta$' + 'w', rotation = 0, labelpad= 10)\nplt.xlabel('Ca global')\nplt.title('Increasing supervising signal')\nplt.show()",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "Old.increasing_supervising_signal_experiment",
        "description": "Old.increasing_supervising_signal_experiment",
        "peekOfCode": "l = plt.ylabel(r'$\\Delta$' + 'w', rotation = 0, labelpad= 10)\nplt.xlabel('Ca global')\nplt.title('Increasing supervising signal')\nplt.show()",
        "detail": "Old.increasing_supervising_signal_experiment",
        "documentation": {}
    },
    {
        "label": "theta_d",
        "kind": 5,
        "importPath": "Old.param_dicts_from_Demystifying_Calcium",
        "description": "Old.param_dicts_from_Demystifying_Calcium",
        "peekOfCode": "theta_d = 0.45\ntheta_p = 0.85\n# eta_dict_no_drift_SBC = {(-np.inf, theta_d): 0, (theta_d, theta_p): 0.15,\n#                      (theta_p, np.inf): 0.25}\neta_dict_no_drift_SBC = {(-np.inf, theta_d): 0, (theta_d, theta_p): 0.15,\n                     (theta_p, np.inf): 0.15}\nFP_calcium_dict_SBC = {(0, theta_d): 0.5, (theta_d, theta_p): 0.25,\n                                     (theta_p, np.inf): 1}\nparam_dict_for_plasticity_graphs_sbc = [\n    {\"eta\": 0.2, \"hard_threshold\": 0, \"k_d\": 0.25, \"k_p\": 1, \"theta_d\": theta_d, \"theta_p\": theta_p,",
        "detail": "Old.param_dicts_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "theta_p",
        "kind": 5,
        "importPath": "Old.param_dicts_from_Demystifying_Calcium",
        "description": "Old.param_dicts_from_Demystifying_Calcium",
        "peekOfCode": "theta_p = 0.85\n# eta_dict_no_drift_SBC = {(-np.inf, theta_d): 0, (theta_d, theta_p): 0.15,\n#                      (theta_p, np.inf): 0.25}\neta_dict_no_drift_SBC = {(-np.inf, theta_d): 0, (theta_d, theta_p): 0.15,\n                     (theta_p, np.inf): 0.15}\nFP_calcium_dict_SBC = {(0, theta_d): 0.5, (theta_d, theta_p): 0.25,\n                                     (theta_p, np.inf): 1}\nparam_dict_for_plasticity_graphs_sbc = [\n    {\"eta\": 0.2, \"hard_threshold\": 0, \"k_d\": 0.25, \"k_p\": 1, \"theta_d\": theta_d, \"theta_p\": theta_p,\n     \"b1\": 80, \"b2\": 80},",
        "detail": "Old.param_dicts_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "eta_dict_no_drift_SBC",
        "kind": 5,
        "importPath": "Old.param_dicts_from_Demystifying_Calcium",
        "description": "Old.param_dicts_from_Demystifying_Calcium",
        "peekOfCode": "eta_dict_no_drift_SBC = {(-np.inf, theta_d): 0, (theta_d, theta_p): 0.15,\n                     (theta_p, np.inf): 0.15}\nFP_calcium_dict_SBC = {(0, theta_d): 0.5, (theta_d, theta_p): 0.25,\n                                     (theta_p, np.inf): 1}\nparam_dict_for_plasticity_graphs_sbc = [\n    {\"eta\": 0.2, \"hard_threshold\": 0, \"k_d\": 0.25, \"k_p\": 1, \"theta_d\": theta_d, \"theta_p\": theta_p,\n     \"b1\": 80, \"b2\": 80},\n    {\"eta_dict\": eta_dict_no_drift_SBC, \"FP_calcium_dict\": FP_calcium_dict_SBC, \"soft_threshold\": 0}]",
        "detail": "Old.param_dicts_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "FP_calcium_dict_SBC",
        "kind": 5,
        "importPath": "Old.param_dicts_from_Demystifying_Calcium",
        "description": "Old.param_dicts_from_Demystifying_Calcium",
        "peekOfCode": "FP_calcium_dict_SBC = {(0, theta_d): 0.5, (theta_d, theta_p): 0.25,\n                                     (theta_p, np.inf): 1}\nparam_dict_for_plasticity_graphs_sbc = [\n    {\"eta\": 0.2, \"hard_threshold\": 0, \"k_d\": 0.25, \"k_p\": 1, \"theta_d\": theta_d, \"theta_p\": theta_p,\n     \"b1\": 80, \"b2\": 80},\n    {\"eta_dict\": eta_dict_no_drift_SBC, \"FP_calcium_dict\": FP_calcium_dict_SBC, \"soft_threshold\": 0}]",
        "detail": "Old.param_dicts_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "param_dict_for_plasticity_graphs_sbc",
        "kind": 5,
        "importPath": "Old.param_dicts_from_Demystifying_Calcium",
        "description": "Old.param_dicts_from_Demystifying_Calcium",
        "peekOfCode": "param_dict_for_plasticity_graphs_sbc = [\n    {\"eta\": 0.2, \"hard_threshold\": 0, \"k_d\": 0.25, \"k_p\": 1, \"theta_d\": theta_d, \"theta_p\": theta_p,\n     \"b1\": 80, \"b2\": 80},\n    {\"eta_dict\": eta_dict_no_drift_SBC, \"FP_calcium_dict\": FP_calcium_dict_SBC, \"soft_threshold\": 0}]",
        "detail": "Old.param_dicts_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "Perceptron_Calcitron",
        "kind": 6,
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "peekOfCode": "class Perceptron_Calcitron(Calcitron):\n    def delta_bias(self, eta_b, y_hat_binary, y):\n        if y_hat_binary == 1 and y == 0: #false positive\n            return -eta_b\n        elif y_hat_binary == 0 and y == 1: #false negative\n            return eta_b\n        else:\n            return 0\n    def multiple_epoch_training(self, num_of_epochs, X, y, protocol, param_dict,\n                                a1=0.35, a2=0.55, plot= False, fixed_weights = 0,",
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "peekOfCode": "eta = 0.00004\n#for asymptotic\nf_d = 0.2\nf_p = 1\n#for linear:\n# f_d = -1\n# f_p = 1\n#eta = 0.00001 - worked for p =100, N = 100 10000 epochs  and for p = 200, N = 100, 15000 epochs\n#eta = 0.0001 - worked at P=550 , N=300\nPlasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),",
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "f_d",
        "kind": 5,
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "peekOfCode": "f_d = 0.2\nf_p = 1\n#for linear:\n# f_d = -1\n# f_p = 1\n#eta = 0.00001 - worked for p =100, N = 100 10000 epochs  and for p = 200, N = 100, 15000 epochs\n#eta = 0.0001 - worked at P=550 , N=300\nPlasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                Region(name='D', bounds=(0.5, 0.6), fp=0.2, eta=4e-05, fp_color='b', bar_code_color='b'),\n                Region(name='P', bounds=(0.6, 0.8), fp=1, eta=4e-05, fp_color='r', bar_code_color='r'),",
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "f_p",
        "kind": 5,
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "peekOfCode": "f_p = 1\n#for linear:\n# f_d = -1\n# f_p = 1\n#eta = 0.00001 - worked for p =100, N = 100 10000 epochs  and for p = 200, N = 100, 15000 epochs\n#eta = 0.0001 - worked at P=550 , N=300\nPlasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                Region(name='D', bounds=(0.5, 0.6), fp=0.2, eta=4e-05, fp_color='b', bar_code_color='b'),\n                Region(name='P', bounds=(0.6, 0.8), fp=1, eta=4e-05, fp_color='r', bar_code_color='r'),\n                Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='g')])",
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "#eta",
        "kind": 5,
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "peekOfCode": "#eta = 0.00001 - worked for p =100, N = 100 10000 epochs  and for p = 200, N = 100, 15000 epochs\n#eta = 0.0001 - worked at P=550 , N=300\nPlasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                Region(name='D', bounds=(0.5, 0.6), fp=0.2, eta=4e-05, fp_color='b', bar_code_color='b'),\n                Region(name='P', bounds=(0.6, 0.8), fp=1, eta=4e-05, fp_color='r', bar_code_color='r'),\n                Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='g')])\n# pr_critic = pr.Plasticity_Rule(eta_dict, FP_dict, name_dict=name_dict, color_dict=\n#                                  {\"N\": \"k\", \"D\": \"b\", \"P\": \"r\", \"PPNZ\": \"g\"})\nclass Perceptron_Calcitron(Calcitron):\n    def delta_bias(self, eta_b, y_hat_binary, y):",
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "#eta",
        "kind": 5,
        "importPath": "Old.Perceptron_Calcitron_old",
        "description": "Old.Perceptron_Calcitron_old",
        "peekOfCode": "#eta = 0.0001 - worked at P=550 , N=300\nPlasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                Region(name='D', bounds=(0.5, 0.6), fp=0.2, eta=4e-05, fp_color='b', bar_code_color='b'),\n                Region(name='P', bounds=(0.6, 0.8), fp=1, eta=4e-05, fp_color='r', bar_code_color='r'),\n                Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='g')])\n# pr_critic = pr.Plasticity_Rule(eta_dict, FP_dict, name_dict=name_dict, color_dict=\n#                                  {\"N\": \"k\", \"D\": \"b\", \"P\": \"r\", \"PPNZ\": \"g\"})\nclass Perceptron_Calcitron(Calcitron):\n    def delta_bias(self, eta_b, y_hat_binary, y):\n        if y_hat_binary == 1 and y == 0: #false positive",
        "detail": "Old.Perceptron_Calcitron_old",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "kind": 6,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "class Plasticity_Rule:\n    def __init__(self, eta_dict, fp_dict, name_dict=None, color_dict = {'N':'w','D':'b','P':'r'}, keys_are_name=False, rule='FPLR'):\n        '''\n        initialization with eta dict and fp dict, name_dict is {\"region name\": (interval start), (interval end)}\n        If keys are name = False, initialize with eta_dict and fp_dict as {(interval start, interval end):eta}\n        if keys_are_name = True, initialize with  as {\"region name\" :eta}\n        '''\n        self.name_dict = name_dict\n        self.rule = rule\n        if keys_are_name:",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "calcium_step",
        "kind": 2,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "def calcium_step(height, delay_dur=canonical_delay_dur, stim_duration=canonical_stim_dur, end_dur=canonical_end_dur):\n    return [0 for it in range(delay_dur)] + [height for it in range(stim_duration)] + [0 for it in range(end_dur)]\ndef step_function_old(x, thresholds, heights, theta_0=0):\n    return sum([(heights[it + 1] - heights[it]) * np.heaviside(x - thresholds[it], 0)\n                for it in range(len(thresholds))]) + \\\n           heights[0]\ndef step_function(x, thresholds, heights, theta_0 = 0):\n    thetas = [theta_0] + thresholds #append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:] #sort both the thresholds by height",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "step_function_old",
        "kind": 2,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "def step_function_old(x, thresholds, heights, theta_0=0):\n    return sum([(heights[it + 1] - heights[it]) * np.heaviside(x - thresholds[it], 0)\n                for it in range(len(thresholds))]) + \\\n           heights[0]\ndef step_function(x, thresholds, heights, theta_0 = 0):\n    thetas = [theta_0] + thresholds #append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:] #sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype = float)[sort_inds] #maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "step_function",
        "kind": 2,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "def step_function(x, thresholds, heights, theta_0 = 0):\n    thetas = [theta_0] + thresholds #append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:] #sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype = float)[sort_inds] #maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])\n                * np.heaviside(x - sorted_thresholds[it], 0)\n                for it in range(len(sorted_thresholds))]) + \\\n           sorted_heights[0]\ndef sym_log(x):",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "sym_log",
        "kind": 2,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "def sym_log(x):\n    x_norm = np.sign(x) * np.log10(abs(x) + 1)\n    return x_norm\ndef quiver_norm(x):\n    min_arrow_length = 4\n    max_arrow_length = 5\n    x_new = x\n    x_new[np.abs(np.round(x, decimals=10)) == 0] = np.nan\n    logs = np.log(np.abs(x_new))\n    return np.sign(x) * (np.log10(1 + abs(x) / (10 ** -3)))",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "quiver_norm",
        "kind": 2,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "def quiver_norm(x):\n    min_arrow_length = 4\n    max_arrow_length = 5\n    x_new = x\n    x_new[np.abs(np.round(x, decimals=10)) == 0] = np.nan\n    logs = np.log(np.abs(x_new))\n    return np.sign(x) * (np.log10(1 + abs(x) / (10 ** -3)))\ndef phase_plane(matrix_for_plot, x, y, ss_x=20, ss_y=10, norm=SymLogNorm(linthresh=10 ** -3), ax=None):\n    X1, Y1 = np.meshgrid(x, y)  # create 2 matrices\n    U = np.zeros_like(matrix_for_plot)",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "phase_plane",
        "kind": 2,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "def phase_plane(matrix_for_plot, x, y, ss_x=20, ss_y=10, norm=SymLogNorm(linthresh=10 ** -3), ax=None):\n    X1, Y1 = np.meshgrid(x, y)  # create 2 matrices\n    U = np.zeros_like(matrix_for_plot)\n    V = np.array(matrix_for_plot)\n    arrow_start_x = 15\n    arrow_start_y = 0\n    V1 = quiver_norm(V[arrow_start_x::ss_x, arrow_start_y::ss_y])\n    ax.quiver(X1[arrow_start_x::ss_x, arrow_start_y::ss_y], Y1[arrow_start_x::ss_x, arrow_start_y::ss_y],\n              U[arrow_start_x::ss_x, arrow_start_y::ss_y], V1, width=0.02)\nclass Plasticity_Rule:",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "canonical_delay_dur",
        "kind": 5,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "canonical_delay_dur = 5\ncanonical_stim_dur = 30\ncanonical_end_dur = 30\ndef calcium_step(height, delay_dur=canonical_delay_dur, stim_duration=canonical_stim_dur, end_dur=canonical_end_dur):\n    return [0 for it in range(delay_dur)] + [height for it in range(stim_duration)] + [0 for it in range(end_dur)]\ndef step_function_old(x, thresholds, heights, theta_0=0):\n    return sum([(heights[it + 1] - heights[it]) * np.heaviside(x - thresholds[it], 0)\n                for it in range(len(thresholds))]) + \\\n           heights[0]\ndef step_function(x, thresholds, heights, theta_0 = 0):",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "canonical_stim_dur",
        "kind": 5,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "canonical_stim_dur = 30\ncanonical_end_dur = 30\ndef calcium_step(height, delay_dur=canonical_delay_dur, stim_duration=canonical_stim_dur, end_dur=canonical_end_dur):\n    return [0 for it in range(delay_dur)] + [height for it in range(stim_duration)] + [0 for it in range(end_dur)]\ndef step_function_old(x, thresholds, heights, theta_0=0):\n    return sum([(heights[it + 1] - heights[it]) * np.heaviside(x - thresholds[it], 0)\n                for it in range(len(thresholds))]) + \\\n           heights[0]\ndef step_function(x, thresholds, heights, theta_0 = 0):\n    thetas = [theta_0] + thresholds #append the zero threshold",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "canonical_end_dur",
        "kind": 5,
        "importPath": "Old.Plasticity_Rule",
        "description": "Old.Plasticity_Rule",
        "peekOfCode": "canonical_end_dur = 30\ndef calcium_step(height, delay_dur=canonical_delay_dur, stim_duration=canonical_stim_dur, end_dur=canonical_end_dur):\n    return [0 for it in range(delay_dur)] + [height for it in range(stim_duration)] + [0 for it in range(end_dur)]\ndef step_function_old(x, thresholds, heights, theta_0=0):\n    return sum([(heights[it + 1] - heights[it]) * np.heaviside(x - thresholds[it], 0)\n                for it in range(len(thresholds))]) + \\\n           heights[0]\ndef step_function(x, thresholds, heights, theta_0 = 0):\n    thetas = [theta_0] + thresholds #append the zero threshold\n    sort_inds = np.argsort(thetas)",
        "detail": "Old.Plasticity_Rule",
        "documentation": {}
    },
    {
        "label": "delta_w_matrix",
        "kind": 2,
        "importPath": "Old.plot_functions_from_Demystifying_Calcium",
        "description": "Old.plot_functions_from_Demystifying_Calcium",
        "peekOfCode": "def delta_w_matrix(func_list, Calcium_Range, Weight_Range, param_dict):\n    deltaW_matrix_list = []\n    for i in range(len(func_list)):\n        deltaW_matrix = [[func_list[i](c, w, param_dict[i]) for c in Calcium_Range] for w in Weight_Range]\n        deltaW_matrix_list.append(deltaW_matrix)\n    return deltaW_matrix_list\ndef delta_w_graph(subgraph, loc, x_axis, lines_for_plot, theta_d, theta_p):\n    range_of_colors = np.linspace(0, 1, len(lines_for_plot))\n    colors = [mpl.cm.Wistia(x) for x in range_of_colors]\n    for n, color in enumerate(colors):",
        "detail": "Old.plot_functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "delta_w_graph",
        "kind": 2,
        "importPath": "Old.plot_functions_from_Demystifying_Calcium",
        "description": "Old.plot_functions_from_Demystifying_Calcium",
        "peekOfCode": "def delta_w_graph(subgraph, loc, x_axis, lines_for_plot, theta_d, theta_p):\n    range_of_colors = np.linspace(0, 1, len(lines_for_plot))\n    colors = [mpl.cm.Wistia(x) for x in range_of_colors]\n    for n, color in enumerate(colors):\n        subgraph[loc].plot(x_axis, lines_for_plot[n], color=color)\n    subgraph[loc].set_xticks([theta_d, theta_p])\n    subgraph[loc].set_xticklabels([r'$\\theta_D$', r'$\\theta_P$'])\n    subgraph[loc].set_xlabel('$\\mathregular{[Ca^{2+}]}$', labelpad = -4, fontsize = 13)\ndef delta_w_matrix(func_list, Calcium_Range, Weight_Range, param_dict):\n    deltaW_matrix_list = []",
        "detail": "Old.plot_functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "delta_w_matrix",
        "kind": 2,
        "importPath": "Old.plot_functions_from_Demystifying_Calcium",
        "description": "Old.plot_functions_from_Demystifying_Calcium",
        "peekOfCode": "def delta_w_matrix(func_list, Calcium_Range, Weight_Range, param_dict):\n    deltaW_matrix_list = []\n    for i in range(len(func_list)):\n        deltaW_matrix = [[func_list[i](c, w, param_dict[i]) for c in Calcium_Range] for w in Weight_Range]\n        deltaW_matrix_list.append(deltaW_matrix)\n    return deltaW_matrix_list\ndef delta_w_imshow(subgraph, loc, matrix_for_plot, C_range_in_matrix, weight_range_in_matrix, theta_d, theta_p, norm = None):\n    bound = max([abs(np.amin(matrix_for_plot)), abs(np.amax(matrix_for_plot))])\n    if norm == None:\n        subgraph[loc].imshow(matrix_for_plot, cmap=\"coolwarm\", aspect=\"auto\",",
        "detail": "Old.plot_functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "delta_w_imshow",
        "kind": 2,
        "importPath": "Old.plot_functions_from_Demystifying_Calcium",
        "description": "Old.plot_functions_from_Demystifying_Calcium",
        "peekOfCode": "def delta_w_imshow(subgraph, loc, matrix_for_plot, C_range_in_matrix, weight_range_in_matrix, theta_d, theta_p, norm = None):\n    bound = max([abs(np.amin(matrix_for_plot)), abs(np.amax(matrix_for_plot))])\n    if norm == None:\n        subgraph[loc].imshow(matrix_for_plot, cmap=\"coolwarm\", aspect=\"auto\",\n                  extent=[0, C_range_in_matrix[-1], weight_range_in_matrix[0], weight_range_in_matrix[-1]],\n                  origin=\"lower\", vmin=-bound, vmax=bound)\n        subgraph[loc].set_xticks([theta_d, theta_p])\n        subgraph[loc].set_xticklabels([r'$\\theta_D$', r'$\\theta_P$'])\n        subgraph[loc].set_xlabel('$\\mathregular{[Ca^{2+}]}$', labelpad = -4, fontsize =13 )\n    else:",
        "detail": "Old.plot_functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "w_graph_different_fps",
        "kind": 2,
        "importPath": "Old.plot_functions_from_Demystifying_Calcium",
        "description": "Old.plot_functions_from_Demystifying_Calcium",
        "peekOfCode": "def w_graph_different_fps(subgraph, loc, C_range_potentiation, C_range_depression, start_weight, fp_min, fp_max, protocol, duration,\n                           param_dict, dif_func_list=False, no_row_col = False, no_fp = 0):\n    if no_row_col == True:\n        subgraph.plot(range(len(C_range_potentiation)),\n                                fdc.run_plasticity(C_range_potentiation, fp_min, protocol,\n                                                  param_dict[protocol], dif_func_list),\n                                \"r\", linestyle=\":\")\n        subgraph.plot(range(len(C_range_potentiation)),\n                                fdc.run_plasticity(C_range_potentiation, start_weight, protocol,\n                                                  param_dict[protocol], dif_func_list),",
        "detail": "Old.plot_functions_from_Demystifying_Calcium",
        "documentation": {}
    },
    {
        "label": "SeabornFig2Grid",
        "kind": 6,
        "importPath": "Old.seaborn_grid",
        "description": "Old.seaborn_grid",
        "peekOfCode": "class SeabornFig2Grid():\n    def __init__(self, seaborngrid, fig, subplot_spec):\n        self.fig = fig\n        self.sg = seaborngrid\n        self.subplot = subplot_spec\n        if isinstance(self.sg, sns.axisgrid.FacetGrid) or \\\n                isinstance(self.sg, sns.axisgrid.PairGrid):\n            self._movegrid()\n        elif isinstance(self.sg, sns.axisgrid.JointGrid):\n            self._movejointgrid()",
        "detail": "Old.seaborn_grid",
        "documentation": {}
    },
    {
        "label": "our_constraint1",
        "kind": 2,
        "importPath": "Old.threshold_solver",
        "description": "Old.threshold_solver",
        "peekOfCode": "def our_constraint1(alpha, delta, theta_p, theta_d, eta, r, dist = 1):\n     if (alpha > theta_p-theta_d) and (alpha < theta_d) and (delta < theta_d) and (alpha+delta > theta_p) \\\n             and (theta_p>theta_d) and (alpha*(1+eta)<theta_d) and ((alpha*(1+eta)*(np.e**(-dist**2/r))+delta)>theta_d) \\\n             and ((alpha*(1+eta)*(np.e**(-dist**2/r))+delta)<theta_p) and ((alpha*1*(np.e**(-dist**2/r))+delta)<theta_d):\n         return True\n# def our_constraint2(alpha, delta, theta_p, theta_d, eta, r, dist = 2):\n#     if (alpha*(1+eta)*(np.e**(-dist**2/r))>theta_d) \\\n#              and (alpha*(1+eta)*(np.e**(-dist**2/r))<theta_p):\n#         #and (((alpha*np.e**(-1/r))<theta_d)\n# (((alpha*np.e**(-1/r))+delta)<theta_d) or \\",
        "detail": "Old.threshold_solver",
        "documentation": {}
    },
    {
        "label": "problem",
        "kind": 5,
        "importPath": "Old.threshold_solver",
        "description": "Old.threshold_solver",
        "peekOfCode": "problem = constraint.Problem()\nproblem.addVariable('alpha', [0.7])\nproblem.addVariable('delta', [0.9])\nproblem.addVariable('theta_p', [cf.theta_p])\nproblem.addVariable('theta_d',[cf.theta_d])\nproblem.addVariable('eta',np.arange(0,1.5,0.1))\nproblem.addVariable('r',np.arange(0.01,9,0.05))\ndef our_constraint1(alpha, delta, theta_p, theta_d, eta, r, dist = 1):\n     if (alpha > theta_p-theta_d) and (alpha < theta_d) and (delta < theta_d) and (alpha+delta > theta_p) \\\n             and (theta_p>theta_d) and (alpha*(1+eta)<theta_d) and ((alpha*(1+eta)*(np.e**(-dist**2/r))+delta)>theta_d) \\",
        "detail": "Old.threshold_solver",
        "documentation": {}
    },
    {
        "label": "solutions",
        "kind": 5,
        "importPath": "Old.threshold_solver",
        "description": "Old.threshold_solver",
        "peekOfCode": "solutions = problem.getSolutions()\n# Easier way to  and see all solutions\nfor solution in solutions:\n    (solution)\n# Prettier way to  and see all solutions\nlength = len(solutions)\n(length)\n(\"('alpha', 'delta', 'theta_p', 'theta_d', 'eta', 'r') ∈ {\", end=\"\")\n# for index, solution in enumerate(solutions):\n#     if index == length - 1:",
        "detail": "Old.threshold_solver",
        "documentation": {}
    },
    {
        "label": "length",
        "kind": 5,
        "importPath": "Old.threshold_solver",
        "description": "Old.threshold_solver",
        "peekOfCode": "length = len(solutions)\n(length)\n(\"('alpha', 'delta', 'theta_p', 'theta_d', 'eta', 'r') ∈ {\", end=\"\")\n# for index, solution in enumerate(solutions):\n#     if index == length - 1:\n#         (\"({},{},{},{},{})\".format(round(solution['alpha'], 1),round(solution['delta'],1), round(solution['theta_d'],1)\n#                                      , round(solution['theta_p'],1), round(solution['eta'],1), round(solution['r'], 1)), end=\"\\n\")\n#     else:\n#         (\"({},{},{},{},{}),\".format(round(solution['alpha'],1), round(solution['delta'],1), round(solution['theta_d'],1)\n#                                       , round(solution['theta_p'],1), round(solution['eta'],1), round(solution['r'], 1)), end=\"\\n\")",
        "detail": "Old.threshold_solver",
        "documentation": {}
    },
    {
        "label": "Calcitron",
        "kind": 6,
        "importPath": "calcitron",
        "description": "calcitron",
        "peekOfCode": "class Calcitron:\n    def __init__(self, coeffs, plasticity_rule, supervisor=sprv.null_supervisor(),\n                 activation_function = 'threshold', bias = 0, w_init = 'middle'):\n        #possible activation functions are 'linear', 'threshold'\n        self.coeffs = coeffs\n        self.alpha = coeffs[0]\n        self.beta = coeffs[1]\n        self.gamma = coeffs[2]\n        self.delta = coeffs[3]\n        self.name = \"base\"",
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "cmap",
        "kind": 5,
        "importPath": "calcitron",
        "description": "calcitron",
        "peekOfCode": "cmap = mpl.cm.get_cmap('Wistia')\nclass Calcitron:\n    def __init__(self, coeffs, plasticity_rule, supervisor=sprv.null_supervisor(),\n                 activation_function = 'threshold', bias = 0, w_init = 'middle'):\n        #possible activation functions are 'linear', 'threshold'\n        self.coeffs = coeffs\n        self.alpha = coeffs[0]\n        self.beta = coeffs[1]\n        self.gamma = coeffs[2]\n        self.delta = coeffs[3]",
        "detail": "calcitron",
        "documentation": {}
    },
    {
        "label": "replace_all",
        "kind": 2,
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "peekOfCode": "def replace_all(text, dic):\n    for i, j in dic.items():\n        text = text.replace(i, j)\n    return text\ndef texify(strings):\n    strings = np.atleast_1d(strings)\n    greek = ['alpha', 'beta', 'gamma', 'delta', 'theta']\n    greekdic = {x: '\\\\' + x for x in greek}\n    new_strings = [r'$' + replace_all(string, greekdic) + '$' for string in strings]\n    if len(new_strings) == 1:",
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "texify",
        "kind": 2,
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "peekOfCode": "def texify(strings):\n    strings = np.atleast_1d(strings)\n    greek = ['alpha', 'beta', 'gamma', 'delta', 'theta']\n    greekdic = {x: '\\\\' + x for x in greek}\n    new_strings = [r'$' + replace_all(string, greekdic) + '$' for string in strings]\n    if len(new_strings) == 1:\n        return new_strings[0]\n    else:\n        return new_strings\ndef calcium_barplot(binary_mat, coeffs, rule, x_labels, used_coeff_inds = [0, 1, 2, 3], ax=None,",
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "calcium_barplot",
        "kind": 2,
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "peekOfCode": "def calcium_barplot(binary_mat, coeffs, rule, x_labels, used_coeff_inds = [0, 1, 2, 3], ax=None,\n                    rotation=0, set_ylim = True):\n    '''\n    '''\n    (f'coeffs: {coeffs}', f'rule: {rule}', f'x_labels: {x_labels}', f'used_coeff_inds: {used_coeff_inds}')\n    binary_mat = np.atleast_2d(binary_mat)\n    y_list = []\n    used_coeffs = [coeffs[i] for i in used_coeff_inds]\n    used_coeff_names = [coeff_names[i] for i in used_coeff_inds]\n    for num_row, value in enumerate(used_coeffs):",
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "coeff_names",
        "kind": 5,
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "peekOfCode": "coeff_names = ['alpha', 'beta', 'gamma', 'delta']\ncolor_dict = [\"g\", \"tab:orange\", \"hotpink\", \"k\"]\nlabel_dict = [r'$C^i_{local}$', r'$C_{het}$', r'$C_{BAP}$', r'$C_{SPRV}$']\ndef replace_all(text, dic):\n    for i, j in dic.items():\n        text = text.replace(i, j)\n    return text\ndef texify(strings):\n    strings = np.atleast_1d(strings)\n    greek = ['alpha', 'beta', 'gamma', 'delta', 'theta']",
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "color_dict",
        "kind": 5,
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "peekOfCode": "color_dict = [\"g\", \"tab:orange\", \"hotpink\", \"k\"]\nlabel_dict = [r'$C^i_{local}$', r'$C_{het}$', r'$C_{BAP}$', r'$C_{SPRV}$']\ndef replace_all(text, dic):\n    for i, j in dic.items():\n        text = text.replace(i, j)\n    return text\ndef texify(strings):\n    strings = np.atleast_1d(strings)\n    greek = ['alpha', 'beta', 'gamma', 'delta', 'theta']\n    greekdic = {x: '\\\\' + x for x in greek}",
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "label_dict",
        "kind": 5,
        "importPath": "calcitron_calcium_bar_charts",
        "description": "calcitron_calcium_bar_charts",
        "peekOfCode": "label_dict = [r'$C^i_{local}$', r'$C_{het}$', r'$C_{BAP}$', r'$C_{SPRV}$']\ndef replace_all(text, dic):\n    for i, j in dic.items():\n        text = text.replace(i, j)\n    return text\ndef texify(strings):\n    strings = np.atleast_1d(strings)\n    greek = ['alpha', 'beta', 'gamma', 'delta', 'theta']\n    greekdic = {x: '\\\\' + x for x in greek}\n    new_strings = [r'$' + replace_all(string, greekdic) + '$' for string in strings]",
        "detail": "calcitron_calcium_bar_charts",
        "documentation": {}
    },
    {
        "label": "compute_distance_grid",
        "kind": 2,
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "peekOfCode": "def compute_distance_grid(X, Y, lines):\n    Z = np.full(X.shape, np.inf)\n    for i in prange(X.shape[0]):\n        for j in prange(X.shape[1]):\n            x, y = X[i, j], Y[i, j]\n            for k in range(lines.shape[0]):\n                a, b, c = lines[k]\n                distance = np.abs(a * x + b * y + c) / np.sqrt(a ** 2 + b ** 2)\n                if distance < Z[i, j]:\n                    Z[i, j] = distance",
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "find_peaks",
        "kind": 2,
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "peekOfCode": "def find_peaks(Z_smoothed, grid_size):\n    peaks = maximum_filter(Z_smoothed, size=(grid_size // 10, grid_size // 10)) == Z_smoothed\n    peak_indices = np.where(peaks)\n    return peak_indices\ndef example_find_peaks(lines, grid_size=200, sigma=4, plot = False):\n    # Define bounds of the plane\n    x_min, x_max = 0, 1.2\n    y_min, y_max = 0, 1.2\n    x_grid = np.linspace(x_min, x_max, grid_size)\n    y_grid = np.linspace(y_min, y_max, grid_size)",
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "example_find_peaks",
        "kind": 2,
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "peekOfCode": "def example_find_peaks(lines, grid_size=200, sigma=4, plot = False):\n    # Define bounds of the plane\n    x_min, x_max = 0, 1.2\n    y_min, y_max = 0, 1.2\n    x_grid = np.linspace(x_min, x_max, grid_size)\n    y_grid = np.linspace(y_min, y_max, grid_size)\n    X, Y = np.meshgrid(x_grid, y_grid)\n    # Convert lines to NumPy array\n    lines_array = np.array(lines)\n    # Compute distance grid",
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "plot_peaks",
        "kind": 2,
        "importPath": "Centroid_finder",
        "description": "Centroid_finder",
        "peekOfCode": "def plot_peaks(X, Y, Z_smoothed, peak_indices, lines, grid_size=200):\n    # Define bounds of the plane\n    x_min, x_max = 0, 1.2\n    y_min, y_max = 0, 1.2\n    x_grid = np.linspace(x_min, x_max, grid_size)\n    y_grid = np.linspace(y_min, y_max, grid_size)\n    # Create a figure with side-by-side subplots\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))\n    # 2D Heatmap\n    im = ax1.imshow(Z_smoothed, extent=(x_min, x_max, y_min, y_max), origin='lower', cmap='jet', alpha=0.8)",
        "detail": "Centroid_finder",
        "documentation": {}
    },
    {
        "label": "SMALL_SIZE",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "SMALL_SIZE = 8\nMEDIUM_SIZE = 10\nBIGGER_SIZE = 12\nPANEL_LABEL_SIZE = 12\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=SMALL_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=MEDIUM_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=MEDIUM_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=MEDIUM_SIZE)  # legend fontsize",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "MEDIUM_SIZE",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "MEDIUM_SIZE = 10\nBIGGER_SIZE = 12\nPANEL_LABEL_SIZE = 12\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=SMALL_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=MEDIUM_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=MEDIUM_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=MEDIUM_SIZE)  # legend fontsize\nplt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "BIGGER_SIZE",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "BIGGER_SIZE = 12\nPANEL_LABEL_SIZE = 12\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=SMALL_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=MEDIUM_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=MEDIUM_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=MEDIUM_SIZE)  # legend fontsize\nplt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title\nPLOT_FOLDER = 'Calc_Plots/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "PANEL_LABEL_SIZE",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "PANEL_LABEL_SIZE = 12\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=SMALL_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=MEDIUM_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=MEDIUM_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=MEDIUM_SIZE)  # legend fontsize\nplt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title\nPLOT_FOLDER = 'Calc_Plots/'\nimport os",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "PLOT_FOLDER",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "PLOT_FOLDER = 'Calc_Plots/'\nimport os\ndropbox_directory = 'C:/Users/tmold/Dropbox/'\ncalcitron_directory = 'C:/Code/Calcitron1'\nPAPER_PLOT_FOLDER = os.path.join(dropbox_directory, 'Calcitron_Paper/', 'Figures/', 'FinalTIFFs/')\n# Ensure the directory exists\nif not os.path.exists(PAPER_PLOT_FOLDER):\n    os.makedirs(PAPER_PLOT_FOLDER)\nDATA_FOLDER = 'Data/'\nPARAMS_FOLDER = 'Params/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "dropbox_directory",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "dropbox_directory = 'C:/Users/tmold/Dropbox/'\ncalcitron_directory = 'C:/Code/Calcitron1'\nPAPER_PLOT_FOLDER = os.path.join(dropbox_directory, 'Calcitron_Paper/', 'Figures/', 'FinalTIFFs/')\n# Ensure the directory exists\nif not os.path.exists(PAPER_PLOT_FOLDER):\n    os.makedirs(PAPER_PLOT_FOLDER)\nDATA_FOLDER = 'Data/'\nPARAMS_FOLDER = 'Params/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "calcitron_directory",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "calcitron_directory = 'C:/Code/Calcitron1'\nPAPER_PLOT_FOLDER = os.path.join(dropbox_directory, 'Calcitron_Paper/', 'Figures/', 'FinalTIFFs/')\n# Ensure the directory exists\nif not os.path.exists(PAPER_PLOT_FOLDER):\n    os.makedirs(PAPER_PLOT_FOLDER)\nDATA_FOLDER = 'Data/'\nPARAMS_FOLDER = 'Params/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "PAPER_PLOT_FOLDER",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "PAPER_PLOT_FOLDER = os.path.join(dropbox_directory, 'Calcitron_Paper/', 'Figures/', 'FinalTIFFs/')\n# Ensure the directory exists\nif not os.path.exists(PAPER_PLOT_FOLDER):\n    os.makedirs(PAPER_PLOT_FOLDER)\nDATA_FOLDER = 'Data/'\nPARAMS_FOLDER = 'Params/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "DATA_FOLDER",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "DATA_FOLDER = 'Data/'\nPARAMS_FOLDER = 'Params/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "PARAMS_FOLDER",
        "kind": 5,
        "importPath": "constants",
        "description": "constants",
        "peekOfCode": "PARAMS_FOLDER = 'Params/'",
        "detail": "constants",
        "documentation": {}
    },
    {
        "label": "theta_d",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "theta_d = 0.45\ntheta_p = 0.85\nregions_FPLR = [Region('N', (-np.inf, 0.5), 0.5, 0),\n           Region('D', (0.5, 1), 0, 0.1),\n           Region('P', (1, np.inf), 1, 0.1)]\nregions_linear = [Region('N', (-np.inf, 0.5), np.nan, 0),\n                  Region('D', (0.5, 1), np.nan, -0.1),\n                  Region('P', (1, np.inf), np.nan, 0.2)]\nLinear = Plasticity_Rule(regions_linear, rule='linear')\nFPLR = Plasticity_Rule(regions_FPLR, rule = 'FPLR')",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "theta_p",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "theta_p = 0.85\nregions_FPLR = [Region('N', (-np.inf, 0.5), 0.5, 0),\n           Region('D', (0.5, 1), 0, 0.1),\n           Region('P', (1, np.inf), 1, 0.1)]\nregions_linear = [Region('N', (-np.inf, 0.5), np.nan, 0),\n                  Region('D', (0.5, 1), np.nan, -0.1),\n                  Region('P', (1, np.inf), np.nan, 0.2)]\nLinear = Plasticity_Rule(regions_linear, rule='linear')\nFPLR = Plasticity_Rule(regions_FPLR, rule = 'FPLR')\nparam_helpers.fig_params([Linear, FPLR], ['E-G', 'H-L'], 1)",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "regions_FPLR",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "regions_FPLR = [Region('N', (-np.inf, 0.5), 0.5, 0),\n           Region('D', (0.5, 1), 0, 0.1),\n           Region('P', (1, np.inf), 1, 0.1)]\nregions_linear = [Region('N', (-np.inf, 0.5), np.nan, 0),\n                  Region('D', (0.5, 1), np.nan, -0.1),\n                  Region('P', (1, np.inf), np.nan, 0.2)]\nLinear = Plasticity_Rule(regions_linear, rule='linear')\nFPLR = Plasticity_Rule(regions_FPLR, rule = 'FPLR')\nparam_helpers.fig_params([Linear, FPLR], ['E-G', 'H-L'], 1)\n# plotting",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "regions_linear",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "regions_linear = [Region('N', (-np.inf, 0.5), np.nan, 0),\n                  Region('D', (0.5, 1), np.nan, -0.1),\n                  Region('P', (1, np.inf), np.nan, 0.2)]\nLinear = Plasticity_Rule(regions_linear, rule='linear')\nFPLR = Plasticity_Rule(regions_FPLR, rule = 'FPLR')\nparam_helpers.fig_params([Linear, FPLR], ['E-G', 'H-L'], 1)\n# plotting\nmosaic = [['D', 'D', 'E', 'F', 'G'], ['H', 'I', 'J', 'K', 'L']]\nlabels = ['D', 'E', 'F', 'G','H','I','J','K','L','','','','']\nfig, axes = plt.subplot_mosaic(mosaic, figsize=(8, 3.5), dpi = 300, constrained_layout=True)",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "Linear",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "Linear = Plasticity_Rule(regions_linear, rule='linear')\nFPLR = Plasticity_Rule(regions_FPLR, rule = 'FPLR')\nparam_helpers.fig_params([Linear, FPLR], ['E-G', 'H-L'], 1)\n# plotting\nmosaic = [['D', 'D', 'E', 'F', 'G'], ['H', 'I', 'J', 'K', 'L']]\nlabels = ['D', 'E', 'F', 'G','H','I','J','K','L','','','','']\nfig, axes = plt.subplot_mosaic(mosaic, figsize=(8, 3.5), dpi = 300, constrained_layout=True)\nLinear.dw_line_plot(ax = axes['D'], show_cbar=False)\nannot_fs = 8\naxes['D'].text(0.55, -0.08, 'Depression', size = annot_fs)",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "FPLR",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "FPLR = Plasticity_Rule(regions_FPLR, rule = 'FPLR')\nparam_helpers.fig_params([Linear, FPLR], ['E-G', 'H-L'], 1)\n# plotting\nmosaic = [['D', 'D', 'E', 'F', 'G'], ['H', 'I', 'J', 'K', 'L']]\nlabels = ['D', 'E', 'F', 'G','H','I','J','K','L','','','','']\nfig, axes = plt.subplot_mosaic(mosaic, figsize=(8, 3.5), dpi = 300, constrained_layout=True)\nLinear.dw_line_plot(ax = axes['D'], show_cbar=False)\nannot_fs = 8\naxes['D'].text(0.55, -0.08, 'Depression', size = annot_fs)\naxes['D'].text(1.05, 0.15, 'Potentiation', size = annot_fs)",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "mosaic",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "mosaic = [['D', 'D', 'E', 'F', 'G'], ['H', 'I', 'J', 'K', 'L']]\nlabels = ['D', 'E', 'F', 'G','H','I','J','K','L','','','','']\nfig, axes = plt.subplot_mosaic(mosaic, figsize=(8, 3.5), dpi = 300, constrained_layout=True)\nLinear.dw_line_plot(ax = axes['D'], show_cbar=False)\nannot_fs = 8\naxes['D'].text(0.55, -0.08, 'Depression', size = annot_fs)\naxes['D'].text(1.05, 0.15, 'Potentiation', size = annot_fs)\naxes['D'].text(0.1, 0.01, 'No change', size=annot_fs)\n# x_d_fill = np.arange(theta_d, theta_p, 0.01)\n# x_p_fill = np.arange(theta_p, theta_p*1.5, 0.01)",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "labels = ['D', 'E', 'F', 'G','H','I','J','K','L','','','','']\nfig, axes = plt.subplot_mosaic(mosaic, figsize=(8, 3.5), dpi = 300, constrained_layout=True)\nLinear.dw_line_plot(ax = axes['D'], show_cbar=False)\nannot_fs = 8\naxes['D'].text(0.55, -0.08, 'Depression', size = annot_fs)\naxes['D'].text(1.05, 0.15, 'Potentiation', size = annot_fs)\naxes['D'].text(0.1, 0.01, 'No change', size=annot_fs)\n# x_d_fill = np.arange(theta_d, theta_p, 0.01)\n# x_p_fill = np.arange(theta_p, theta_p*1.5, 0.01)\n# axes['D'].fill_between(x_d_fill, y2 = eta_dict_lin[\"D\"] * np.ones_like(x_d_fill), y1 = np.zeros_like(x_d_fill), color = 'b')",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "Linear.dw_line_plot(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "Linear.dw_line_plot(ax = axes['D'], show_cbar=False)\nannot_fs = 8\naxes['D'].text(0.55, -0.08, 'Depression', size = annot_fs)\naxes['D'].text(1.05, 0.15, 'Potentiation', size = annot_fs)\naxes['D'].text(0.1, 0.01, 'No change', size=annot_fs)\n# x_d_fill = np.arange(theta_d, theta_p, 0.01)\n# x_p_fill = np.arange(theta_p, theta_p*1.5, 0.01)\n# axes['D'].fill_between(x_d_fill, y2 = eta_dict_lin[\"D\"] * np.ones_like(x_d_fill), y1 = np.zeros_like(x_d_fill), color = 'b')\n# axes['D'].fill_between(x_p_fill, y2 = eta_dict_lin[\"P\"] * np.ones_like(x_p_fill), y1 = np.zeros_like(x_p_fill), color = 'r')\nLinear.dw_imshow(ax = axes['E'])",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "annot_fs",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "annot_fs = 8\naxes['D'].text(0.55, -0.08, 'Depression', size = annot_fs)\naxes['D'].text(1.05, 0.15, 'Potentiation', size = annot_fs)\naxes['D'].text(0.1, 0.01, 'No change', size=annot_fs)\n# x_d_fill = np.arange(theta_d, theta_p, 0.01)\n# x_p_fill = np.arange(theta_p, theta_p*1.5, 0.01)\n# axes['D'].fill_between(x_d_fill, y2 = eta_dict_lin[\"D\"] * np.ones_like(x_d_fill), y1 = np.zeros_like(x_d_fill), color = 'b')\n# axes['D'].fill_between(x_p_fill, y2 = eta_dict_lin[\"P\"] * np.ones_like(x_p_fill), y1 = np.zeros_like(x_p_fill), color = 'r')\nLinear.dw_imshow(ax = axes['E'])\nLinear.Ca_stim_plot(ax = axes['F'])",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "Linear.dw_imshow(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "Linear.dw_imshow(ax = axes['E'])\nLinear.Ca_stim_plot(ax = axes['F'])\nLinear.canonical_weight_change_from_Ca(ax = axes['G'])\nFPLR.fp_and_eta_plot(ax = axes['H'])\nFPLR.dw_line_plot(ax = axes['I'])\nFPLR.dw_imshow(ax = axes['J'])\nLinear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "Linear.Ca_stim_plot(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "Linear.Ca_stim_plot(ax = axes['F'])\nLinear.canonical_weight_change_from_Ca(ax = axes['G'])\nFPLR.fp_and_eta_plot(ax = axes['H'])\nFPLR.dw_line_plot(ax = axes['I'])\nFPLR.dw_imshow(ax = axes['J'])\nLinear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "Linear.canonical_weight_change_from_Ca(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "Linear.canonical_weight_change_from_Ca(ax = axes['G'])\nFPLR.fp_and_eta_plot(ax = axes['H'])\nFPLR.dw_line_plot(ax = axes['I'])\nFPLR.dw_imshow(ax = axes['J'])\nLinear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)\nplt.show()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "FPLR.fp_and_eta_plot(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "FPLR.fp_and_eta_plot(ax = axes['H'])\nFPLR.dw_line_plot(ax = axes['I'])\nFPLR.dw_imshow(ax = axes['J'])\nLinear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)\nplt.show()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "FPLR.dw_line_plot(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "FPLR.dw_line_plot(ax = axes['I'])\nFPLR.dw_imshow(ax = axes['J'])\nLinear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)\nplt.show()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "FPLR.dw_imshow(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "FPLR.dw_imshow(ax = axes['J'])\nLinear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)\nplt.show()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "Linear.Ca_stim_plot(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "Linear.Ca_stim_plot(ax = axes['K'])\nFPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)\nplt.show()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "FPLR.canonical_weight_change_from_Ca(ax",
        "kind": 5,
        "importPath": "Fig1_FPLR",
        "description": "Fig1_FPLR",
        "peekOfCode": "FPLR.canonical_weight_change_from_Ca(ax = axes['L'])\nph.label_panels_mosaic(fig, axes, size = 14)\n# plt.tight_layout()\nplt.savefig(constants.PLOT_FOLDER + '1.svg', dpi = fig.dpi)\nplt.show()",
        "detail": "Fig1_FPLR",
        "documentation": {}
    },
    {
        "label": "bias",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "bias = -1.8\nN = 10\nP = 50\nprob = 0.4\nk = int(N*prob)\neta = 0.1\nseed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "N = 10\nP = 50\nprob = 0.4\nk = int(N*prob)\neta = 0.1\nseed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "P = 50\nprob = 0.4\nk = int(N*prob)\neta = 0.1\nseed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "prob",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "prob = 0.4\nk = int(N*prob)\neta = 0.1\nseed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "k = int(N*prob)\neta = 0.1\nseed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),\n                     Region('D', (0.8, np.inf), 0, eta)]",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "eta = 0.1\nseed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),\n                     Region('D', (0.8, np.inf), 0, eta)]\ntitles = ['Fire together wire together',",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "seed",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "seed = 99\nrng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),\n                     Region('D', (0.8, np.inf), 0, eta)]\ntitles = ['Fire together wire together',\n          'Fire together wire together & \\nOut of sync lose your link',",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "rng",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "rng = np.random.default_rng(seed)\nhebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),\n                     Region('D', (0.8, np.inf), 0, eta)]\ntitles = ['Fire together wire together',\n          'Fire together wire together & \\nOut of sync lose your link',\n          'Fire together lose your link',",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "hebb_regions",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                  Region('D', (0.5, 0.8), 0, eta),\n                  Region('P', (0.8, np.inf), 1, eta)]\nanti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),\n                     Region('D', (0.8, np.inf), 0, eta)]\ntitles = ['Fire together wire together',\n          'Fire together wire together & \\nOut of sync lose your link',\n          'Fire together lose your link',\n          'Fire together lose your link & \\nOut of sync wire together']",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "anti_hebb_regions",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "anti_hebb_regions = [Region('N', (-np.inf, 0.5), 0, 0),\n                     Region('P', (0.5, 0.8), 1, eta),\n                     Region('D', (0.8, np.inf), 0, eta)]\ntitles = ['Fire together wire together',\n          'Fire together wire together & \\nOut of sync lose your link',\n          'Fire together lose your link',\n          'Fire together lose your link & \\nOut of sync wire together']\nall_rules = [PR(hebb_regions), PR(hebb_regions), PR(hebb_regions), PR(anti_hebb_regions)]\nall_coeffs = [[0.4,0,0.45,0], [0.55,0,0.7,0], [0.4,0,0.3,0], [0.55,0,0.6,0]]\nw_init = (bias / k * np.ones(N)) + rng.standard_normal(N)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "titles",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "titles = ['Fire together wire together',\n          'Fire together wire together & \\nOut of sync lose your link',\n          'Fire together lose your link',\n          'Fire together lose your link & \\nOut of sync wire together']\nall_rules = [PR(hebb_regions), PR(hebb_regions), PR(hebb_regions), PR(anti_hebb_regions)]\nall_coeffs = [[0.4,0,0.45,0], [0.55,0,0.7,0], [0.4,0,0.3,0], [0.55,0,0.6,0]]\nw_init = (bias / k * np.ones(N)) + rng.standard_normal(N)\ncalcitrons = [Calcitron(coeffs, rule, bias = bias, w_init = w_init) for rule, coeffs in zip(all_rules, all_coeffs)]\n# Generate the random local inputs using the seeded random number generator\nlocal_inputs = np.array(rng.random((P, N)) <= prob, dtype=int)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "all_rules",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "all_rules = [PR(hebb_regions), PR(hebb_regions), PR(hebb_regions), PR(anti_hebb_regions)]\nall_coeffs = [[0.4,0,0.45,0], [0.55,0,0.7,0], [0.4,0,0.3,0], [0.55,0,0.6,0]]\nw_init = (bias / k * np.ones(N)) + rng.standard_normal(N)\ncalcitrons = [Calcitron(coeffs, rule, bias = bias, w_init = w_init) for rule, coeffs in zip(all_rules, all_coeffs)]\n# Generate the random local inputs using the seeded random number generator\nlocal_inputs = np.array(rng.random((P, N)) <= prob, dtype=int)\n# Create the list of all local inputs\nall_local_inputs = [local_inputs for i in range(4)]\nx_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "all_coeffs",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "all_coeffs = [[0.4,0,0.45,0], [0.55,0,0.7,0], [0.4,0,0.3,0], [0.55,0,0.6,0]]\nw_init = (bias / k * np.ones(N)) + rng.standard_normal(N)\ncalcitrons = [Calcitron(coeffs, rule, bias = bias, w_init = w_init) for rule, coeffs in zip(all_rules, all_coeffs)]\n# Generate the random local inputs using the seeded random number generator\nlocal_inputs = np.array(rng.random((P, N)) <= prob, dtype=int)\n# Create the list of all local inputs\nall_local_inputs = [local_inputs for i in range(4)]\nx_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "w_init",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "w_init = (bias / k * np.ones(N)) + rng.standard_normal(N)\ncalcitrons = [Calcitron(coeffs, rule, bias = bias, w_init = w_init) for rule, coeffs in zip(all_rules, all_coeffs)]\n# Generate the random local inputs using the seeded random number generator\nlocal_inputs = np.array(rng.random((P, N)) <= prob, dtype=int)\n# Create the list of all local inputs\nall_local_inputs = [local_inputs for i in range(4)]\nx_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "calcitrons",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "calcitrons = [Calcitron(coeffs, rule, bias = bias, w_init = w_init) for rule, coeffs in zip(all_rules, all_coeffs)]\n# Generate the random local inputs using the seeded random number generator\nlocal_inputs = np.array(rng.random((P, N)) <= prob, dtype=int)\n# Create the list of all local inputs\nall_local_inputs = [local_inputs for i in range(4)]\nx_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "local_inputs",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "local_inputs = np.array(rng.random((P, N)) <= prob, dtype=int)\n# Create the list of all local inputs\nall_local_inputs = [local_inputs for i in range(4)]\nx_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "all_local_inputs",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "all_local_inputs = [local_inputs for i in range(4)]\nx_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "x_barplot",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "x_barplot = [\"pre\", \"post\", \"both\"]\nalpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)\nfig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "alpha_vector",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "alpha_vector = np.array([1, 0, 1])\ngamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)\nfig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))\nletters = ['A','B','C','D','E','F']",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "gamma_vector",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "gamma_vector = np.array([0, 1, 1])\nbar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)\nfig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))\nletters = ['A','B','C','D','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "bar_matrix",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "bar_matrix = [alpha_vector, gamma_vector]\nall_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)\nfig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))\nletters = ['A','B','C','D','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()\nph.label_panels(fig, labels = labels)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "all_bar_mats",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "all_bar_mats = [bar_matrix, bar_matrix, bar_matrix, bar_matrix]\nall_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)\nfig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))\nletters = ['A','B','C','D','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()\nph.label_panels(fig, labels = labels)\nplt.savefig(constants.PLOT_FOLDER + '2.svg', dpi=fig.dpi)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "all_bar_titles",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "all_bar_titles = [x_barplot,x_barplot,x_barplot,x_barplot]\nfig, results_subplots, bar_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, all_bar_titles, all_local_inputs, coeffs_to_use=[0, 2], plot_cbar = [3])\nprint(bar_subplots)\nfig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))\nletters = ['A','B','C','D','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()\nph.label_panels(fig, labels = labels)\nplt.savefig(constants.PLOT_FOLDER + '2.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '2.tiff', dpi = fig.dpi)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "fig.axes[0].legend(bbox_to_anchor",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "fig.axes[0].legend(bbox_to_anchor = (-0.2, 1.1))\nletters = ['A','B','C','D','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()\nph.label_panels(fig, labels = labels)\nplt.savefig(constants.PLOT_FOLDER + '2.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '2.tiff', dpi = fig.dpi)\n#plt.show()\nrule_titles = ['A1-F1', 'A2-F2', 'A3-F3', 'A4-F4']\nparam_helpers.fig_params(calcitrons, rule_titles, 2)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "letters = ['A','B','C','D','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()\nph.label_panels(fig, labels = labels)\nplt.savefig(constants.PLOT_FOLDER + '2.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '2.tiff', dpi = fig.dpi)\n#plt.show()\nrule_titles = ['A1-F1', 'A2-F2', 'A3-F3', 'A4-F4']\nparam_helpers.fig_params(calcitrons, rule_titles, 2)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "labels = np.array([[letter + str(j) for letter in letters] for j in range(1,5)]).T.ravel()\nph.label_panels(fig, labels = labels)\nplt.savefig(constants.PLOT_FOLDER + '2.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '2.tiff', dpi = fig.dpi)\n#plt.show()\nrule_titles = ['A1-F1', 'A2-F2', 'A3-F3', 'A4-F4']\nparam_helpers.fig_params(calcitrons, rule_titles, 2)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "rule_titles",
        "kind": 5,
        "importPath": "Fig2_Hebb",
        "description": "Fig2_Hebb",
        "peekOfCode": "rule_titles = ['A1-F1', 'A2-F2', 'A3-F3', 'A4-F4']\nparam_helpers.fig_params(calcitrons, rule_titles, 2)",
        "detail": "Fig2_Hebb",
        "documentation": {}
    },
    {
        "label": "rules_from_dict",
        "kind": 2,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "def rules_from_dict(dicts):\n    rules = []\n    coeffs = []\n    calcitrons = []\n    for d in dicts:\n        if d['theta_D'] < d['theta_P']:\n            regions = [Region('N', (-np.inf, d['theta_D']), 0.5, eta = 0),\n                       Region('D', (d['theta_D'], d['theta_P']), 0, eta = 1),\n                       Region('P', (d['theta_P'], np.inf), 1, eta = 1)]\n        else:",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "create_peak_annotations",
        "kind": 2,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "def create_peak_annotations(peaks, theta_D, theta_P, special = None):\n    annotations = {}\n    for i in range(len(peaks[0])):\n        x = peaks[0][i]\n        y = peaks[1][i]\n        rule = rules_from_dict([{'alpha': x, 'gamma': y, 'theta_D': theta_D, 'theta_P': theta_P}])[0][0]\n        x_code = int(rule.bar_code_from_C(x))\n        y_code = int(rule.bar_code_from_C(y))\n        xy_code = int(rule.bar_code_from_C(x+y))\n        annotation = rule.region_names[x_code] + rule.region_names[y_code] + rule.region_names[xy_code]",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plot_lines_with_annotations",
        "kind": 2,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "def plot_lines_with_annotations(ax, lines, annotations, theta_d, theta_p, line_colors, specials):\n    # Define bounds of the plane\n    x_min, x_max = 0, 1.2\n    y_min, y_max = 0, 1.2\n    x_grid = np.linspace(x_min, x_max, 200)\n    # Plot the lines with specified colors\n    for line in lines:\n        a, b, c = line\n        color = line_colors.get(tuple(line), 'black')\n        if b != 0:",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "order_indices",
        "kind": 2,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "def order_indices(key, order):\n    return [order[char] for char in key]\n# Define parameters\nthetas = [[(0.3,1.0), (0.7,1.0)], [(1.0,0.3), (1.0,0.7)]]\nfig_names = ['3', '3_1']\nannotation_orders = [{'N': 0, 'D': 1, 'P': 2}, {'N': 0, 'P': 1, 'D': 2}]\nspecials = [['DDD', 'NNP'],['PPP', 'NND']]\nmx = 1.2\nfor fig_num in range(len(fig_names)):\n    threshold_sets = thetas[fig_num]",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['font.size']",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "plt.rcParams['font.size'] = 12\nplt.rcParams['axes.titlesize'] = 14\nplt.rcParams['xtick.labelsize'] = 14\nplt.rcParams['ytick.labelsize'] = 14\nplt.rcParams['legend.fontsize'] = 14\nplt.rcParams['axes.labelsize'] = 14\n#plt.ion()\ndef rules_from_dict(dicts):\n    rules = []\n    coeffs = []",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['axes.titlesize']",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "plt.rcParams['axes.titlesize'] = 14\nplt.rcParams['xtick.labelsize'] = 14\nplt.rcParams['ytick.labelsize'] = 14\nplt.rcParams['legend.fontsize'] = 14\nplt.rcParams['axes.labelsize'] = 14\n#plt.ion()\ndef rules_from_dict(dicts):\n    rules = []\n    coeffs = []\n    calcitrons = []",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['xtick.labelsize']",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "plt.rcParams['xtick.labelsize'] = 14\nplt.rcParams['ytick.labelsize'] = 14\nplt.rcParams['legend.fontsize'] = 14\nplt.rcParams['axes.labelsize'] = 14\n#plt.ion()\ndef rules_from_dict(dicts):\n    rules = []\n    coeffs = []\n    calcitrons = []\n    for d in dicts:",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['ytick.labelsize']",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "plt.rcParams['ytick.labelsize'] = 14\nplt.rcParams['legend.fontsize'] = 14\nplt.rcParams['axes.labelsize'] = 14\n#plt.ion()\ndef rules_from_dict(dicts):\n    rules = []\n    coeffs = []\n    calcitrons = []\n    for d in dicts:\n        if d['theta_D'] < d['theta_P']:",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['legend.fontsize']",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "plt.rcParams['legend.fontsize'] = 14\nplt.rcParams['axes.labelsize'] = 14\n#plt.ion()\ndef rules_from_dict(dicts):\n    rules = []\n    coeffs = []\n    calcitrons = []\n    for d in dicts:\n        if d['theta_D'] < d['theta_P']:\n            regions = [Region('N', (-np.inf, d['theta_D']), 0.5, eta = 0),",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['axes.labelsize']",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "plt.rcParams['axes.labelsize'] = 14\n#plt.ion()\ndef rules_from_dict(dicts):\n    rules = []\n    coeffs = []\n    calcitrons = []\n    for d in dicts:\n        if d['theta_D'] < d['theta_P']:\n            regions = [Region('N', (-np.inf, d['theta_D']), 0.5, eta = 0),\n                       Region('D', (d['theta_D'], d['theta_P']), 0, eta = 1),",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "thetas",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "thetas = [[(0.3,1.0), (0.7,1.0)], [(1.0,0.3), (1.0,0.7)]]\nfig_names = ['3', '3_1']\nannotation_orders = [{'N': 0, 'D': 1, 'P': 2}, {'N': 0, 'P': 1, 'D': 2}]\nspecials = [['DDD', 'NNP'],['PPP', 'NND']]\nmx = 1.2\nfor fig_num in range(len(fig_names)):\n    threshold_sets = thetas[fig_num]\n    annotation_order = annotation_orders[fig_num]\n    special = specials[fig_num]\n    fig, axes = plt.subplots(4, 4, figsize=(16, 12))",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "fig_names",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "fig_names = ['3', '3_1']\nannotation_orders = [{'N': 0, 'D': 1, 'P': 2}, {'N': 0, 'P': 1, 'D': 2}]\nspecials = [['DDD', 'NNP'],['PPP', 'NND']]\nmx = 1.2\nfor fig_num in range(len(fig_names)):\n    threshold_sets = thetas[fig_num]\n    annotation_order = annotation_orders[fig_num]\n    special = specials[fig_num]\n    fig, axes = plt.subplots(4, 4, figsize=(16, 12))\n    all_dicts = [{} for _ in range(2)]",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "annotation_orders",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "annotation_orders = [{'N': 0, 'D': 1, 'P': 2}, {'N': 0, 'P': 1, 'D': 2}]\nspecials = [['DDD', 'NNP'],['PPP', 'NND']]\nmx = 1.2\nfor fig_num in range(len(fig_names)):\n    threshold_sets = thetas[fig_num]\n    annotation_order = annotation_orders[fig_num]\n    special = specials[fig_num]\n    fig, axes = plt.subplots(4, 4, figsize=(16, 12))\n    all_dicts = [{} for _ in range(2)]\n    linaxes = [axes[0,0], axes [3,2]] #axes for the line plot",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "specials",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "specials = [['DDD', 'NNP'],['PPP', 'NND']]\nmx = 1.2\nfor fig_num in range(len(fig_names)):\n    threshold_sets = thetas[fig_num]\n    annotation_order = annotation_orders[fig_num]\n    special = specials[fig_num]\n    fig, axes = plt.subplots(4, 4, figsize=(16, 12))\n    all_dicts = [{} for _ in range(2)]\n    linaxes = [axes[0,0], axes [3,2]] #axes for the line plot\n    for threshold_num, threshold_set in enumerate(threshold_sets):",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "mx",
        "kind": 5,
        "importPath": "Fig3_PrePost",
        "description": "Fig3_PrePost",
        "peekOfCode": "mx = 1.2\nfor fig_num in range(len(fig_names)):\n    threshold_sets = thetas[fig_num]\n    annotation_order = annotation_orders[fig_num]\n    special = specials[fig_num]\n    fig, axes = plt.subplots(4, 4, figsize=(16, 12))\n    all_dicts = [{} for _ in range(2)]\n    linaxes = [axes[0,0], axes [3,2]] #axes for the line plot\n    for threshold_num, threshold_set in enumerate(threshold_sets):\n        theta_d, theta_p = threshold_set",
        "detail": "Fig3_PrePost",
        "documentation": {}
    },
    {
        "label": "frequency_dep_imshow",
        "kind": 2,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "def frequency_dep_imshow(alpha, gamma, x_array, y_hat_array, theta_d = 0.5, theta_p = 0.8, ax = None):\n    x_alpha = alpha * x_array\n    y_hat_gamma = gamma * y_hat_array\n    mat_for_plot = [[x_i + y_i for x_i in x_alpha] for y_i in y_hat_gamma]\n    calc_mat = np.array(mat_for_plot)\n    mat_for_plot = np.zeros_like(calc_mat)\n    mat_for_plot[calc_mat > theta_p] = 2\n    mat_for_plot[calc_mat <= theta_d] = 0\n    mat_for_plot[(calc_mat <= theta_p) * (calc_mat > theta_d)] = 1\n    im = ax.imshow(np.array(mat_for_plot), cmap=ListedColormap(['white', 'blue', 'red']), aspect=\"equal\",origin=\"lower\", extent = [0,x_array[-1],0, y_hat_array[-1]])",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "fig = plt.figure(constrained_layout=True, figsize=(8, 5), dpi = 300)\nfig_gs = GridSpec(2,5, figure=fig)\nbar_subplot = fig.add_subplot(fig_gs[0, :])\nhm_subplots = [fig.add_subplot(fig_gs[1,i])for i in range(5)]\nx_barplot = [r\"$\\mathregular{x_{i}}$\" + \"=1\", r\"$\\mathregular{x_{i}}$\" + \"=2\",\n             r\"$\\mathregular{x_{i}}$\" + \"=3\",\n             r\"$\\hat{y}$\"+ \"=1\", r\"$\\hat{y}$\"+ \"=2\", r\"$\\hat{y}$\"+ \"=3\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=2\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=3\"]",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "fig_gs",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "fig_gs = GridSpec(2,5, figure=fig)\nbar_subplot = fig.add_subplot(fig_gs[0, :])\nhm_subplots = [fig.add_subplot(fig_gs[1,i])for i in range(5)]\nx_barplot = [r\"$\\mathregular{x_{i}}$\" + \"=1\", r\"$\\mathregular{x_{i}}$\" + \"=2\",\n             r\"$\\mathregular{x_{i}}$\" + \"=3\",\n             r\"$\\hat{y}$\"+ \"=1\", r\"$\\hat{y}$\"+ \"=2\", r\"$\\hat{y}$\"+ \"=3\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=2\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=3\"]\nalpha_vector = np.array([1,2,3,0,0,0,1,2,1])",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "bar_subplot",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "bar_subplot = fig.add_subplot(fig_gs[0, :])\nhm_subplots = [fig.add_subplot(fig_gs[1,i])for i in range(5)]\nx_barplot = [r\"$\\mathregular{x_{i}}$\" + \"=1\", r\"$\\mathregular{x_{i}}$\" + \"=2\",\n             r\"$\\mathregular{x_{i}}$\" + \"=3\",\n             r\"$\\hat{y}$\"+ \"=1\", r\"$\\hat{y}$\"+ \"=2\", r\"$\\hat{y}$\"+ \"=3\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=2\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=3\"]\nalpha_vector = np.array([1,2,3,0,0,0,1,2,1])\ngamma_vector = np.array([0,0,0,1,2,3,1,1,3])",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "hm_subplots",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "hm_subplots = [fig.add_subplot(fig_gs[1,i])for i in range(5)]\nx_barplot = [r\"$\\mathregular{x_{i}}$\" + \"=1\", r\"$\\mathregular{x_{i}}$\" + \"=2\",\n             r\"$\\mathregular{x_{i}}$\" + \"=3\",\n             r\"$\\hat{y}$\"+ \"=1\", r\"$\\hat{y}$\"+ \"=2\", r\"$\\hat{y}$\"+ \"=3\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=2\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=3\"]\nalpha_vector = np.array([1,2,3,0,0,0,1,2,1])\ngamma_vector = np.array([0,0,0,1,2,3,1,1,3])\nbar_matrix = [alpha_vector, gamma_vector]",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "x_barplot",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "x_barplot = [r\"$\\mathregular{x_{i}}$\" + \"=1\", r\"$\\mathregular{x_{i}}$\" + \"=2\",\n             r\"$\\mathregular{x_{i}}$\" + \"=3\",\n             r\"$\\hat{y}$\"+ \"=1\", r\"$\\hat{y}$\"+ \"=2\", r\"$\\hat{y}$\"+ \"=3\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=2\\n& \" + r\"$\\hat{y}$\"+ \"=1\",\n             r\"$\\mathregular{x_{i}}$\" + \"=1\\n& \" + r\"$\\hat{y}$\"+ \"=3\"]\nalpha_vector = np.array([1,2,3,0,0,0,1,2,1])\ngamma_vector = np.array([0,0,0,1,2,3,1,1,3])\nbar_matrix = [alpha_vector, gamma_vector]\neta = 0.1",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "alpha_vector",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "alpha_vector = np.array([1,2,3,0,0,0,1,2,1])\ngamma_vector = np.array([0,0,0,1,2,3,1,1,3])\nbar_matrix = [alpha_vector, gamma_vector]\neta = 0.1\nfrequency_dep = {'alpha': 0.3, 'gamma': 0.3,'theta_d': 0.5, 'theta_p': 0.8}\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, 0.5), 0.5, 0),\n                                   Region('D', (0.5, 0.8), 0, eta),\n                                   Region('P', (0.8, np.inf), 1, eta)])\ncoeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "gamma_vector",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "gamma_vector = np.array([0,0,0,1,2,3,1,1,3])\nbar_matrix = [alpha_vector, gamma_vector]\neta = 0.1\nfrequency_dep = {'alpha': 0.3, 'gamma': 0.3,'theta_d': 0.5, 'theta_p': 0.8}\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, 0.5), 0.5, 0),\n                                   Region('D', (0.5, 0.8), 0, eta),\n                                   Region('P', (0.8, np.inf), 1, eta)])\ncoeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,\n                used_coeff_inds=[0, 2],",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "bar_matrix",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "bar_matrix = [alpha_vector, gamma_vector]\neta = 0.1\nfrequency_dep = {'alpha': 0.3, 'gamma': 0.3,'theta_d': 0.5, 'theta_p': 0.8}\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, 0.5), 0.5, 0),\n                                   Region('D', (0.5, 0.8), 0, eta),\n                                   Region('P', (0.8, np.inf), 1, eta)])\ncoeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,\n                used_coeff_inds=[0, 2],\n                x_labels=x_barplot, ax=bar_subplot)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "eta = 0.1\nfrequency_dep = {'alpha': 0.3, 'gamma': 0.3,'theta_d': 0.5, 'theta_p': 0.8}\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, 0.5), 0.5, 0),\n                                   Region('D', (0.5, 0.8), 0, eta),\n                                   Region('P', (0.8, np.inf), 1, eta)])\ncoeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,\n                used_coeff_inds=[0, 2],\n                x_labels=x_barplot, ax=bar_subplot)\nbar_subplot.legend(bbox_to_anchor = (0, 1.05))",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "frequency_dep",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "frequency_dep = {'alpha': 0.3, 'gamma': 0.3,'theta_d': 0.5, 'theta_p': 0.8}\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, 0.5), 0.5, 0),\n                                   Region('D', (0.5, 0.8), 0, eta),\n                                   Region('P', (0.8, np.inf), 1, eta)])\ncoeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,\n                used_coeff_inds=[0, 2],\n                x_labels=x_barplot, ax=bar_subplot)\nbar_subplot.legend(bbox_to_anchor = (0, 1.05))\ndef frequency_dep_imshow(alpha, gamma, x_array, y_hat_array, theta_d = 0.5, theta_p = 0.8, ax = None):",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "rule",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "rule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, 0.5), 0.5, 0),\n                                   Region('D', (0.5, 0.8), 0, eta),\n                                   Region('P', (0.8, np.inf), 1, eta)])\ncoeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,\n                used_coeff_inds=[0, 2],\n                x_labels=x_barplot, ax=bar_subplot)\nbar_subplot.legend(bbox_to_anchor = (0, 1.05))\ndef frequency_dep_imshow(alpha, gamma, x_array, y_hat_array, theta_d = 0.5, theta_p = 0.8, ax = None):\n    x_alpha = alpha * x_array",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "coeffs",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "coeffs = [0.3, 0, 0.3, 0]\ncalcium_barplot(bar_matrix, coeffs, rule,\n                used_coeff_inds=[0, 2],\n                x_labels=x_barplot, ax=bar_subplot)\nbar_subplot.legend(bbox_to_anchor = (0, 1.05))\ndef frequency_dep_imshow(alpha, gamma, x_array, y_hat_array, theta_d = 0.5, theta_p = 0.8, ax = None):\n    x_alpha = alpha * x_array\n    y_hat_gamma = gamma * y_hat_array\n    mat_for_plot = [[x_i + y_i for x_i in x_alpha] for y_i in y_hat_gamma]\n    calc_mat = np.array(mat_for_plot)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "bar_subplot.legend(bbox_to_anchor",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "bar_subplot.legend(bbox_to_anchor = (0, 1.05))\ndef frequency_dep_imshow(alpha, gamma, x_array, y_hat_array, theta_d = 0.5, theta_p = 0.8, ax = None):\n    x_alpha = alpha * x_array\n    y_hat_gamma = gamma * y_hat_array\n    mat_for_plot = [[x_i + y_i for x_i in x_alpha] for y_i in y_hat_gamma]\n    calc_mat = np.array(mat_for_plot)\n    mat_for_plot = np.zeros_like(calc_mat)\n    mat_for_plot[calc_mat > theta_p] = 2\n    mat_for_plot[calc_mat <= theta_d] = 0\n    mat_for_plot[(calc_mat <= theta_p) * (calc_mat > theta_d)] = 1",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "x = np.array(np.arange(0, 4.001, 0.01))\ny_hat = np.array(np.arange(0, 4.001, 0.01))\nfrequency_dep_imshow(0.3, 0.0, x, y_hat, ax = hm_subplots[0])\nfrequency_dep_imshow(0.3, 0.15, x, y_hat, ax = hm_subplots[1])\nfrequency_dep_imshow(0.3, 0.3, x, y_hat, ax=hm_subplots[2])\nfrequency_dep_imshow(0.15, 0.3, x, y_hat, ax=hm_subplots[3])\nim = frequency_dep_imshow(0, 0.3, x, y_hat, ax=hm_subplots[4])\ncbar = plt.colorbar(im, label='Plasticity', ax=hm_subplots[-1], fraction=0.046, pad=0.04)\ncbar.set_ticks([0.33, 0.99, 1.65], labels=rule.region_names)\nph.label_panels(fig, labels = ['A','B1','B2','B3','B4','B5'], size = 12)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "y_hat",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "y_hat = np.array(np.arange(0, 4.001, 0.01))\nfrequency_dep_imshow(0.3, 0.0, x, y_hat, ax = hm_subplots[0])\nfrequency_dep_imshow(0.3, 0.15, x, y_hat, ax = hm_subplots[1])\nfrequency_dep_imshow(0.3, 0.3, x, y_hat, ax=hm_subplots[2])\nfrequency_dep_imshow(0.15, 0.3, x, y_hat, ax=hm_subplots[3])\nim = frequency_dep_imshow(0, 0.3, x, y_hat, ax=hm_subplots[4])\ncbar = plt.colorbar(im, label='Plasticity', ax=hm_subplots[-1], fraction=0.046, pad=0.04)\ncbar.set_ticks([0.33, 0.99, 1.65], labels=rule.region_names)\nph.label_panels(fig, labels = ['A','B1','B2','B3','B4','B5'], size = 12)\nplt.savefig(constants.PLOT_FOLDER + '4.svg', dpi=fig.dpi)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "im",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "im = frequency_dep_imshow(0, 0.3, x, y_hat, ax=hm_subplots[4])\ncbar = plt.colorbar(im, label='Plasticity', ax=hm_subplots[-1], fraction=0.046, pad=0.04)\ncbar.set_ticks([0.33, 0.99, 1.65], labels=rule.region_names)\nph.label_panels(fig, labels = ['A','B1','B2','B3','B4','B5'], size = 12)\nplt.savefig(constants.PLOT_FOLDER + '4.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '4.tiff', dpi = fig.dpi)\n#plt.show()\npanel_labels = ['A','B1','B2','B3','B4','B5']\n#first A then the examples\ncoeffs_mat = [[0.3,0,0.3,0], [0.3,0,0,0], [0.3,0,0.15,0],[0.3,0,0.3,0],[0.15,0,0.3,0],[0,0,0.3,0]]",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "cbar",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "cbar = plt.colorbar(im, label='Plasticity', ax=hm_subplots[-1], fraction=0.046, pad=0.04)\ncbar.set_ticks([0.33, 0.99, 1.65], labels=rule.region_names)\nph.label_panels(fig, labels = ['A','B1','B2','B3','B4','B5'], size = 12)\nplt.savefig(constants.PLOT_FOLDER + '4.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '4.tiff', dpi = fig.dpi)\n#plt.show()\npanel_labels = ['A','B1','B2','B3','B4','B5']\n#first A then the examples\ncoeffs_mat = [[0.3,0,0.3,0], [0.3,0,0,0], [0.3,0,0.15,0],[0.3,0,0.3,0],[0.15,0,0.3,0],[0,0,0.3,0]]\nparam_helpers.fig_params([rule for i in range(len(panel_labels))], panel_labels, 4, coeffs = coeffs_mat)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "panel_labels",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "panel_labels = ['A','B1','B2','B3','B4','B5']\n#first A then the examples\ncoeffs_mat = [[0.3,0,0.3,0], [0.3,0,0,0], [0.3,0,0.15,0],[0.3,0,0.3,0],[0.15,0,0.3,0],[0,0,0.3,0]]\nparam_helpers.fig_params([rule for i in range(len(panel_labels))], panel_labels, 4, coeffs = coeffs_mat)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "coeffs_mat",
        "kind": 5,
        "importPath": "Fig4_Freq",
        "description": "Fig4_Freq",
        "peekOfCode": "coeffs_mat = [[0.3,0,0.3,0], [0.3,0,0,0], [0.3,0,0.15,0],[0.3,0,0.3,0],[0.15,0,0.3,0],[0,0,0.3,0]]\nparam_helpers.fig_params([rule for i in range(len(panel_labels))], panel_labels, 4, coeffs = coeffs_mat)",
        "detail": "Fig4_Freq",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "fig = plt.figure(constrained_layout=True, figsize=(8, 7), dpi = 300)\nfig_gs = GridSpec(5, 3, figure=fig, width_ratios=[0.5, 1, 0.04])\nexample_axes = fig.add_subplot(fig_gs[0:2, 0])\nbar_axes = fig.add_subplot(fig_gs[2:5, 0])\nresults_axes = {'input':fig.add_subplot(fig_gs[0, 1]),\n                'output': fig.add_subplot(fig_gs[1, 1]),\n                'C': fig.add_subplot(fig_gs[2, 1]),\n                'bar_code': fig.add_subplot(fig_gs[3, 1]),\n                'w': fig.add_subplot(fig_gs[4, 1])}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, 2]), 'C':fig.add_subplot(fig_gs[2, 2]),",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "fig_gs",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "fig_gs = GridSpec(5, 3, figure=fig, width_ratios=[0.5, 1, 0.04])\nexample_axes = fig.add_subplot(fig_gs[0:2, 0])\nbar_axes = fig.add_subplot(fig_gs[2:5, 0])\nresults_axes = {'input':fig.add_subplot(fig_gs[0, 1]),\n                'output': fig.add_subplot(fig_gs[1, 1]),\n                'C': fig.add_subplot(fig_gs[2, 1]),\n                'bar_code': fig.add_subplot(fig_gs[3, 1]),\n                'w': fig.add_subplot(fig_gs[4, 1])}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, 2]), 'C':fig.add_subplot(fig_gs[2, 2]),\n#              'bar_code':fig.add_subplot(fig_gs[3, 2]), 'w':fig.add_subplot(fig_gs[4, 2])}",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "example_axes",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "example_axes = fig.add_subplot(fig_gs[0:2, 0])\nbar_axes = fig.add_subplot(fig_gs[2:5, 0])\nresults_axes = {'input':fig.add_subplot(fig_gs[0, 1]),\n                'output': fig.add_subplot(fig_gs[1, 1]),\n                'C': fig.add_subplot(fig_gs[2, 1]),\n                'bar_code': fig.add_subplot(fig_gs[3, 1]),\n                'w': fig.add_subplot(fig_gs[4, 1])}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, 2]), 'C':fig.add_subplot(fig_gs[2, 2]),\n#              'bar_code':fig.add_subplot(fig_gs[3, 2]), 'w':fig.add_subplot(fig_gs[4, 2])}\nwmin = 1.0",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "bar_axes",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "bar_axes = fig.add_subplot(fig_gs[2:5, 0])\nresults_axes = {'input':fig.add_subplot(fig_gs[0, 1]),\n                'output': fig.add_subplot(fig_gs[1, 1]),\n                'C': fig.add_subplot(fig_gs[2, 1]),\n                'bar_code': fig.add_subplot(fig_gs[3, 1]),\n                'w': fig.add_subplot(fig_gs[4, 1])}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, 2]), 'C':fig.add_subplot(fig_gs[2, 2]),\n#              'bar_code':fig.add_subplot(fig_gs[3, 2]), 'w':fig.add_subplot(fig_gs[4, 2])}\nwmin = 1.0\nwmax = 3",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "results_axes",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "results_axes = {'input':fig.add_subplot(fig_gs[0, 1]),\n                'output': fig.add_subplot(fig_gs[1, 1]),\n                'C': fig.add_subplot(fig_gs[2, 1]),\n                'bar_code': fig.add_subplot(fig_gs[3, 1]),\n                'w': fig.add_subplot(fig_gs[4, 1])}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, 2]), 'C':fig.add_subplot(fig_gs[2, 2]),\n#              'bar_code':fig.add_subplot(fig_gs[3, 2]), 'w':fig.add_subplot(fig_gs[4, 2])}\nwmin = 1.0\nwmax = 3\nepsilon = 0.1",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "wmin",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "wmin = 1.0\nwmax = 3\nepsilon = 0.1\nN = 12\nP = 60\ndensity = 0.4\nk = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "wmax",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "wmax = 3\nepsilon = 0.1\nN = 12\nP = 60\ndensity = 0.4\nk = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "epsilon = 0.1\nN = 12\nP = 60\ndensity = 0.4\nk = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "N = 12\nP = 60\ndensity = 0.4\nk = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "P = 60\ndensity = 0.4\nk = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "density",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "density = 0.4\nk = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "k = int(N * density)\nalpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "alpha = 2\nbeta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "beta",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "beta = 0.2\nbias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "bias",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "bias = -k * (wmin + (wmax-wmin)/2)\neta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "eta = 0.025\nsignal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))\nexample_axes.set_xticks(range(len(exemplars)), labels = ['Signal', 'Noise', 'Noise','Signal','Noise'])",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "signal_prob",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "signal_prob = 0.4\ntheta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))\nexample_axes.set_xticks(range(len(exemplars)), labels = ['Signal', 'Noise', 'Noise','Signal','Noise'])\nexample_axes.set_ylabel(r'$\\bf{Input}$' + '\\nsyn #')",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "theta_d",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "theta_d = round((beta * k) - epsilon,1)\ntheta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))\nexample_axes.set_xticks(range(len(exemplars)), labels = ['Signal', 'Noise', 'Noise','Signal','Noise'])\nexample_axes.set_ylabel(r'$\\bf{Input}$' + '\\nsyn #')\nx_barplot = ['Inactive', 'Active']",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "theta_p",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "theta_p = round(theta_d + alpha - epsilon,1)\nseed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))\nexample_axes.set_xticks(range(len(exemplars)), labels = ['Signal', 'Noise', 'Noise','Signal','Noise'])\nexample_axes.set_ylabel(r'$\\bf{Input}$' + '\\nsyn #')\nx_barplot = ['Inactive', 'Active']\nalpha_vector = np.array([0,1])",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "seed",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "seed = 2\nsignal, labels, local_inputs = signal_noise_gen(N, P, signal_prob=signal_prob, density=density, seed = seed)\nexemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))\nexample_axes.set_xticks(range(len(exemplars)), labels = ['Signal', 'Noise', 'Noise','Signal','Noise'])\nexample_axes.set_ylabel(r'$\\bf{Input}$' + '\\nsyn #')\nx_barplot = ['Inactive', 'Active']\nalpha_vector = np.array([0,1])\nbeta_vector = np.array([np.sum(signal), np.sum(signal)])",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "exemplars",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "exemplars = np.array([signal, pattern_gen(N, 1, density=density, seed = None),\n                      pattern_gen(N, 1, density=density, seed = None),signal, pattern_gen(N, 1, density=density, seed = None)])\nexample_axes.imshow(exemplars.T, aspect = 'auto', origin = 'lower', cmap = ListedColormap(['w','k']))\nexample_axes.set_xticks(range(len(exemplars)), labels = ['Signal', 'Noise', 'Noise','Signal','Noise'])\nexample_axes.set_ylabel(r'$\\bf{Input}$' + '\\nsyn #')\nx_barplot = ['Inactive', 'Active']\nalpha_vector = np.array([0,1])\nbeta_vector = np.array([np.sum(signal), np.sum(signal)])\nbar_matrix = [alpha_vector, beta_vector]\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "x_barplot",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "x_barplot = ['Inactive', 'Active']\nalpha_vector = np.array([0,1])\nbeta_vector = np.array([np.sum(signal), np.sum(signal)])\nbar_matrix = [alpha_vector, beta_vector]\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                   Region('D', (theta_d, theta_p), wmin, eta),\n                                   Region('P', (theta_p, np.inf), wmax, eta)])\ncoeffs = [alpha, beta, 0,0]\ncalcium_barplot(bar_matrix, coeffs, rule, x_barplot, used_coeff_inds= [0,1], ax=bar_axes)\nbar_axes.legend(loc=\"center left\")",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "alpha_vector",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "alpha_vector = np.array([0,1])\nbeta_vector = np.array([np.sum(signal), np.sum(signal)])\nbar_matrix = [alpha_vector, beta_vector]\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                   Region('D', (theta_d, theta_p), wmin, eta),\n                                   Region('P', (theta_p, np.inf), wmax, eta)])\ncoeffs = [alpha, beta, 0,0]\ncalcium_barplot(bar_matrix, coeffs, rule, x_barplot, used_coeff_inds= [0,1], ax=bar_axes)\nbar_axes.legend(loc=\"center left\")\nplot_dict = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "beta_vector",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "beta_vector = np.array([np.sum(signal), np.sum(signal)])\nbar_matrix = [alpha_vector, beta_vector]\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                   Region('D', (theta_d, theta_p), wmin, eta),\n                                   Region('P', (theta_p, np.inf), wmax, eta)])\ncoeffs = [alpha, beta, 0,0]\ncalcium_barplot(bar_matrix, coeffs, rule, x_barplot, used_coeff_inds= [0,1], ax=bar_axes)\nbar_axes.legend(loc=\"center left\")\nplot_dict = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nrng = np.random.default_rng(seed)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "bar_matrix",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "bar_matrix = [alpha_vector, beta_vector]\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                   Region('D', (theta_d, theta_p), wmin, eta),\n                                   Region('P', (theta_p, np.inf), wmax, eta)])\ncoeffs = [alpha, beta, 0,0]\ncalcium_barplot(bar_matrix, coeffs, rule, x_barplot, used_coeff_inds= [0,1], ax=bar_axes)\nbar_axes.legend(loc=\"center left\")\nplot_dict = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nrng = np.random.default_rng(seed)\nw_init = (-bias / k * np.ones(N)) + rng.standard_normal(N)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "rule",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "rule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                   Region('D', (theta_d, theta_p), wmin, eta),\n                                   Region('P', (theta_p, np.inf), wmax, eta)])\ncoeffs = [alpha, beta, 0,0]\ncalcium_barplot(bar_matrix, coeffs, rule, x_barplot, used_coeff_inds= [0,1], ax=bar_axes)\nbar_axes.legend(loc=\"center left\")\nplot_dict = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nrng = np.random.default_rng(seed)\nw_init = (-bias / k * np.ones(N)) + rng.standard_normal(N)\nhetero_calc = Calcitron([alpha, beta, 0, 0], rule, supervisor = supervisors.signal_noise_supervisor(signal),",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "coeffs",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "coeffs = [alpha, beta, 0,0]\ncalcium_barplot(bar_matrix, coeffs, rule, x_barplot, used_coeff_inds= [0,1], ax=bar_axes)\nbar_axes.legend(loc=\"center left\")\nplot_dict = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nrng = np.random.default_rng(seed)\nw_init = (-bias / k * np.ones(N)) + rng.standard_normal(N)\nhetero_calc = Calcitron([alpha, beta, 0, 0], rule, supervisor = supervisors.signal_noise_supervisor(signal),\n                        bias = bias, w_init=w_init)\nhetero_calc.train(local_inputs)\nph.share_axes(list(results_axes.values()), 'both', 'False')",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "plot_dict",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "plot_dict = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nrng = np.random.default_rng(seed)\nw_init = (-bias / k * np.ones(N)) + rng.standard_normal(N)\nhetero_calc = Calcitron([alpha, beta, 0, 0], rule, supervisor = supervisors.signal_noise_supervisor(signal),\n                        bias = bias, w_init=w_init)\nhetero_calc.train(local_inputs)\nph.share_axes(list(results_axes.values()), 'both', 'False')\nhetero_calc.all_plots(axes=results_axes)\ntick_labels = ['N' if val == 0 else 'S' for val in labels]\nfor ax in list(results_axes.values()):",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "rng",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "rng = np.random.default_rng(seed)\nw_init = (-bias / k * np.ones(N)) + rng.standard_normal(N)\nhetero_calc = Calcitron([alpha, beta, 0, 0], rule, supervisor = supervisors.signal_noise_supervisor(signal),\n                        bias = bias, w_init=w_init)\nhetero_calc.train(local_inputs)\nph.share_axes(list(results_axes.values()), 'both', 'False')\nhetero_calc.all_plots(axes=results_axes)\ntick_labels = ['N' if val == 0 else 'S' for val in labels]\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(P), labels = tick_labels, fontsize = 6)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "w_init",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "w_init = (-bias / k * np.ones(N)) + rng.standard_normal(N)\nhetero_calc = Calcitron([alpha, beta, 0, 0], rule, supervisor = supervisors.signal_noise_supervisor(signal),\n                        bias = bias, w_init=w_init)\nhetero_calc.train(local_inputs)\nph.share_axes(list(results_axes.values()), 'both', 'False')\nhetero_calc.all_plots(axes=results_axes)\ntick_labels = ['N' if val == 0 else 'S' for val in labels]\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(P), labels = tick_labels, fontsize = 6)\n# results_axes['output'].set_ylim([0.9*min(y_hat), 1.1*max(y_hat)])",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "hetero_calc",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "hetero_calc = Calcitron([alpha, beta, 0, 0], rule, supervisor = supervisors.signal_noise_supervisor(signal),\n                        bias = bias, w_init=w_init)\nhetero_calc.train(local_inputs)\nph.share_axes(list(results_axes.values()), 'both', 'False')\nhetero_calc.all_plots(axes=results_axes)\ntick_labels = ['N' if val == 0 else 'S' for val in labels]\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(P), labels = tick_labels, fontsize = 6)\n# results_axes['output'].set_ylim([0.9*min(y_hat), 1.1*max(y_hat)])\nph.label_panels(fig, labels=['A', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'], size=12)",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "tick_labels",
        "kind": 5,
        "importPath": "Fig5_hetero",
        "description": "Fig5_hetero",
        "peekOfCode": "tick_labels = ['N' if val == 0 else 'S' for val in labels]\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(P), labels = tick_labels, fontsize = 6)\n# results_axes['output'].set_ylim([0.9*min(y_hat), 1.1*max(y_hat)])\nph.label_panels(fig, labels=['A', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'], size=12)\nplt.savefig(constants.PLOT_FOLDER + '5.svg', dpi=fig.dpi)\nplt.savefig(constants.PAPER_PLOT_FOLDER + '5.tiff', dpi = fig.dpi)\nparam_helpers.fig_params([hetero_calc], ['All'], 5)\nplt.show()",
        "detail": "Fig5_hetero",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "alpha = 0.2\ndelta = 0.6\ntheta_d = 0.5\ntheta_p = 0.7\neta = 1\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                    Region('D', (theta_d, theta_p), 0, eta),\n                                    Region('P', (theta_p, np.inf), 1, eta)])\ncoeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "delta",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "delta = 0.6\ntheta_d = 0.5\ntheta_p = 0.7\neta = 1\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                    Region('D', (theta_d, theta_p), 0, eta),\n                                    Region('P', (theta_p, np.inf), 1, eta)])\ncoeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "theta_d",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "theta_d = 0.5\ntheta_p = 0.7\neta = 1\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                    Region('D', (theta_d, theta_p), 0, eta),\n                                    Region('P', (theta_p, np.inf), 1, eta)])\ncoeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "theta_p",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "theta_p = 0.7\neta = 1\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                    Region('D', (theta_d, theta_p), 0, eta),\n                                    Region('P', (theta_p, np.inf), 1, eta)])\ncoeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0\nexample_col = 0",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "eta = 1\nrule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                    Region('D', (theta_d, theta_p), 0, eta),\n                                    Region('P', (theta_p, np.inf), 1, eta)])\ncoeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0\nexample_col = 0\nbar_col = 0",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "rule",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "rule = pr.Plasticity_Rule(regions=[Region('N', (-np.inf, theta_d), 0.5, 0),\n                                    Region('D', (theta_d, theta_p), 0, eta),\n                                    Region('P', (theta_p, np.inf), 1, eta)])\ncoeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0\nexample_col = 0\nbar_col = 0\nresult_col = 1",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "coeffs",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "coeffs = np.array([alpha, 0, 0, delta])\nfig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0\nexample_col = 0\nbar_col = 0\nresult_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "fig = plt.figure(constrained_layout=True, figsize=(8, 6.7), dpi = 300)\nfig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0\nexample_col = 0\nbar_col = 0\nresult_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "fig_gs",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "fig_gs = GridSpec(6, 2, figure=fig, width_ratios=[1, 3])\nrule_col = 0\nexample_col = 0\nbar_col = 0\nresult_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "rule_col",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "rule_col = 0\nexample_col = 0\nbar_col = 0\nresult_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "example_col",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "example_col = 0\nbar_col = 0\nresult_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "bar_col",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "bar_col = 0\nresult_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "result_col",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "result_col = 1\ncbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "cbar_col",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "cbar_col = 2\nrule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])\nCa_stim = np.zeros(100)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "rule_axes",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "rule_axes = [fig.add_subplot(fig_gs[i, rule_col]) for i in range(3)]\n#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])\nCa_stim = np.zeros(100)\nCa_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "#example_ax",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "#example_ax = fig.add_subplot(fig_gs[4, example_col])\nbar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])\nCa_stim = np.zeros(100)\nCa_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1\nrule.Ca_stim_plot(Ca_stim, line_colors = ['k'], ax = rule_axes[1])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "bar_ax",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "bar_ax = fig.add_subplot(fig_gs[3:, bar_col])\nresult_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])\nCa_stim = np.zeros(100)\nCa_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1\nrule.Ca_stim_plot(Ca_stim, line_colors = ['k'], ax = rule_axes[1])\nrule.weight_change_plot_from_Ca(w0 = 0.5, Ca = Ca_stim, ax = rule_axes[2], line_colors=['k'], fp_colors=['k','b','r'], line_styles=['-'])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "result_names",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "result_names = ['input','Z','C','bar_code','w','output']\nresults_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])\nCa_stim = np.zeros(100)\nCa_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1\nrule.Ca_stim_plot(Ca_stim, line_colors = ['k'], ax = rule_axes[1])\nrule.weight_change_plot_from_Ca(w0 = 0.5, Ca = Ca_stim, ax = rule_axes[2], line_colors=['k'], fp_colors=['k','b','r'], line_styles=['-'])\ncalcitron_x_bar = [\"Active \\nsyn\", \"Plateau\", \"Active +\\nplateau\"]",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "results_axes",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "results_axes = {key:fig.add_subplot(fig_gs[i, result_col]) for i, key in enumerate(result_names)}\n# cbar_axes = {'input': fig.add_subplot(fig_gs[0, cbar_col]), 'C': fig.add_subplot(fig_gs[2, cbar_col]),\n#              'bar_code': fig.add_subplot(fig_gs[3, cbar_col]), 'w': fig.add_subplot(fig_gs[4, cbar_col])}\nrule.fp_and_eta_plot(ax=rule_axes[0])\nCa_stim = np.zeros(100)\nCa_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1\nrule.Ca_stim_plot(Ca_stim, line_colors = ['k'], ax = rule_axes[1])\nrule.weight_change_plot_from_Ca(w0 = 0.5, Ca = Ca_stim, ax = rule_axes[2], line_colors=['k'], fp_colors=['k','b','r'], line_styles=['-'])\ncalcitron_x_bar = [\"Active \\nsyn\", \"Plateau\", \"Active +\\nplateau\"]\nalpha_vector = np.array([1,0,1])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "Ca_stim",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "Ca_stim = np.zeros(100)\nCa_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1\nrule.Ca_stim_plot(Ca_stim, line_colors = ['k'], ax = rule_axes[1])\nrule.weight_change_plot_from_Ca(w0 = 0.5, Ca = Ca_stim, ax = rule_axes[2], line_colors=['k'], fp_colors=['k','b','r'], line_styles=['-'])\ncalcitron_x_bar = [\"Active \\nsyn\", \"Plateau\", \"Active +\\nplateau\"]\nalpha_vector = np.array([1,0,1])\ndelta_vector = np.array([0,1,1])\ncalcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "Ca_stim[[20,50,70]]",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "Ca_stim[[20,50,70]] = np.array([theta_d, theta_p, theta_d]) + 0.1\nrule.Ca_stim_plot(Ca_stim, line_colors = ['k'], ax = rule_axes[1])\nrule.weight_change_plot_from_Ca(w0 = 0.5, Ca = Ca_stim, ax = rule_axes[2], line_colors=['k'], fp_colors=['k','b','r'], line_styles=['-'])\ncalcitron_x_bar = [\"Active \\nsyn\", \"Plateau\", \"Active +\\nplateau\"]\nalpha_vector = np.array([1,0,1])\ndelta_vector = np.array([0,1,1])\ncalcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "rule.weight_change_plot_from_Ca(w0",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "rule.weight_change_plot_from_Ca(w0 = 0.5, Ca = Ca_stim, ax = rule_axes[2], line_colors=['k'], fp_colors=['k','b','r'], line_styles=['-'])\ncalcitron_x_bar = [\"Active \\nsyn\", \"Plateau\", \"Active +\\nplateau\"]\nalpha_vector = np.array([1,0,1])\ndelta_vector = np.array([0,1,1])\ncalcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7\nbar_ax.tick_params(axis='x', labelsize=7)\nN = 14",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "calcitron_x_bar",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "calcitron_x_bar = [\"Active \\nsyn\", \"Plateau\", \"Active +\\nplateau\"]\nalpha_vector = np.array([1,0,1])\ndelta_vector = np.array([0,1,1])\ncalcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7\nbar_ax.tick_params(axis='x', labelsize=7)\nN = 14\nP = 4",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "alpha_vector",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "alpha_vector = np.array([1,0,1])\ndelta_vector = np.array([0,1,1])\ncalcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7\nbar_ax.tick_params(axis='x', labelsize=7)\nN = 14\nP = 4\ndensity = 0.5",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "delta_vector",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "delta_vector = np.array([0,1,1])\ncalcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7\nbar_ax.tick_params(axis='x', labelsize=7)\nN = 14\nP = 4\ndensity = 0.5\nbias = -(density * N - 1)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "calcitron_mat",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "calcitron_mat = [alpha_vector, delta_vector]\ncalcium_barplot(calcitron_mat, coeffs, rule, calcitron_x_bar, used_coeff_inds=[0,3], ax=bar_ax)\nbar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7\nbar_ax.tick_params(axis='x', labelsize=7)\nN = 14\nP = 4\ndensity = 0.5\nbias = -(density * N - 1)\npatterns = pg.pattern_gen(N,P,density)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "bar_ax.legend(bbox_to_anchor",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "bar_ax.legend(bbox_to_anchor = (0, 0.99))\n# Set the xtick label size for bar_ax to 7\nbar_ax.tick_params(axis='x', labelsize=7)\nN = 14\nP = 4\ndensity = 0.5\nbias = -(density * N - 1)\npatterns = pg.pattern_gen(N,P,density)\n# example_ax.imshow(patterns.T, aspect='auto', origin='lower', cmap=ListedColormap(['w', 'k']))\n# example_ax.set_xticks(range(len(patterns)), labels=range(len(patterns)))",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "N = 14\nP = 4\ndensity = 0.5\nbias = -(density * N - 1)\npatterns = pg.pattern_gen(N,P,density)\n# example_ax.imshow(patterns.T, aspect='auto', origin='lower', cmap=ListedColormap(['w', 'k']))\n# example_ax.set_xticks(range(len(patterns)), labels=range(len(patterns)))\ninput_nums = list(range(len(patterns)))*8\ninputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "P = 4\ndensity = 0.5\nbias = -(density * N - 1)\npatterns = pg.pattern_gen(N,P,density)\n# example_ax.imshow(patterns.T, aspect='auto', origin='lower', cmap=ListedColormap(['w', 'k']))\n# example_ax.set_xticks(range(len(patterns)), labels=range(len(patterns)))\ninput_nums = list(range(len(patterns)))*8\ninputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "density",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "density = 0.5\nbias = -(density * N - 1)\npatterns = pg.pattern_gen(N,P,density)\n# example_ax.imshow(patterns.T, aspect='auto', origin='lower', cmap=ListedColormap(['w', 'k']))\n# example_ax.set_xticks(range(len(patterns)), labels=range(len(patterns)))\ninput_nums = list(range(len(patterns)))*8\ninputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "bias",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "bias = -(density * N - 1)\npatterns = pg.pattern_gen(N,P,density)\n# example_ax.imshow(patterns.T, aspect='auto', origin='lower', cmap=ListedColormap(['w', 'k']))\n# example_ax.set_xticks(range(len(patterns)), labels=range(len(patterns)))\ninput_nums = list(range(len(patterns)))*8\ninputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "patterns = pg.pattern_gen(N,P,density)\n# example_ax.imshow(patterns.T, aspect='auto', origin='lower', cmap=ListedColormap(['w', 'k']))\n# example_ax.set_xticks(range(len(patterns)), labels=range(len(patterns)))\ninput_nums = list(range(len(patterns)))*8\ninputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "input_nums",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "input_nums = list(range(len(patterns)))*8\ninputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)\n_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "inputs",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "inputs = [patterns[val] for val in input_nums]\nZ = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)\n_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)\nax.set_xlabel('Pattern #')",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "Z = np.zeros_like(input_nums)\none_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)\n_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)\nax.set_xlabel('Pattern #')\nph.label_panels(fig, labels=['A1', 'A2', 'A3', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'])",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "one_inds",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "one_inds = range(4,len(inputs),7)\nZ = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)\n_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)\nax.set_xlabel('Pattern #')\nph.label_panels(fig, labels=['A1', 'A2', 'A3', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'])\nfig.savefig(ph.SAVE_FOLDER+str(6) +'.svg', dpi = fig.dpi)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "Z",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "Z = [1 if i in one_inds else Z[i] for i in range(len(Z))]\n_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)\n_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)\nax.set_xlabel('Pattern #')\nph.label_panels(fig, labels=['A1', 'A2', 'A3', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'])\nfig.savefig(ph.SAVE_FOLDER+str(6) +'.svg', dpi = fig.dpi)\nfig.savefig(constants.PAPER_PLOT_FOLDER+ str(6) +'.tiff', dpi = fig.dpi)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "_1SFF",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "_1SFF = Calcitron([alpha, 0, 0, delta], rule, supervisor = one_shot_flip_flop_supervisor(y=Z), bias = bias)\n_1SFF.train(inputs)\n_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)\nax.set_xlabel('Pattern #')\nph.label_panels(fig, labels=['A1', 'A2', 'A3', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'])\nfig.savefig(ph.SAVE_FOLDER+str(6) +'.svg', dpi = fig.dpi)\nfig.savefig(constants.PAPER_PLOT_FOLDER+ str(6) +'.tiff', dpi = fig.dpi)\n#plt.show()",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "_1SFF.all_plots(axes",
        "kind": 5,
        "importPath": "Fig6_1SFF",
        "description": "Fig6_1SFF",
        "peekOfCode": "_1SFF.all_plots(axes = results_axes)\nfor ax in list(results_axes.values()):\n    ax.set_xticks(range(len(input_nums)),input_nums)\nax.set_xlabel('Pattern #')\nph.label_panels(fig, labels=['A1', 'A2', 'A3', 'B', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6'])\nfig.savefig(ph.SAVE_FOLDER+str(6) +'.svg', dpi = fig.dpi)\nfig.savefig(constants.PAPER_PLOT_FOLDER+ str(6) +'.tiff', dpi = fig.dpi)\n#plt.show()\nparam_helpers.fig_params([_1SFF], ['All'], 6)",
        "detail": "Fig6_1SFF",
        "documentation": {}
    },
    {
        "label": "rule_from_thetas",
        "kind": 2,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "def rule_from_thetas(thetas):\n    return PR.Plasticity_Rule([Region('N', (-np.inf, thetas[0]), 0.5, 0),\n                              Region('D', (thetas[0], thetas[1]), 0, eta),\n                              Region('P', (thetas[1], np.inf), 0.5, eta)])\nrules = [rule_from_thetas(thetas) for thetas in all_thetas]\nrule_names = ['P supervisor\\n(Global)', 'P supervisor\\n(Targeted)', 'P&D supervisors\\n(Global)', 'P&D supervisors\\n(Targeted)']\ninput_bars = [0, 0, 0, 1, 1, 1]\noutput_bars = [1, 2, 3, 1, 2, 3]\nZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]\nZPs = [all_thetas[0][1]+eps,",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "eps",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "eps = 0.05\nnum_rules = 4\nall_coeffs = [[0, 0, 0.2, 1],\n [0.35, 0, 0.06, 1],\n [0, 0, 0, 1],\n [0.3, 0, 0, 1]]\n# all_coeffs = [[0, 0, 0.2, 1],\n#  [0., 0, 0.06, 1],\n#  [0, 0, 0, 1],\n#  [0.3, 0, 0, 1]]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "num_rules",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "num_rules = 4\nall_coeffs = [[0, 0, 0.2, 1],\n [0.35, 0, 0.06, 1],\n [0, 0, 0, 1],\n [0.3, 0, 0, 1]]\n# all_coeffs = [[0, 0, 0.2, 1],\n#  [0., 0, 0.06, 1],\n#  [0, 0, 0, 1],\n#  [0.3, 0, 0, 1]]\nall_thetas = np.array([[0.5, 1], [0.5, 0.7], [0.5, 1], [0.5, 0.7]])",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "all_coeffs",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "all_coeffs = [[0, 0, 0.2, 1],\n [0.35, 0, 0.06, 1],\n [0, 0, 0, 1],\n [0.3, 0, 0, 1]]\n# all_coeffs = [[0, 0, 0.2, 1],\n#  [0., 0, 0.06, 1],\n#  [0, 0, 0, 1],\n#  [0.3, 0, 0, 1]]\nall_thetas = np.array([[0.5, 1], [0.5, 0.7], [0.5, 1], [0.5, 0.7]])\neta = 0.02",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "all_thetas",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "all_thetas = np.array([[0.5, 1], [0.5, 0.7], [0.5, 1], [0.5, 0.7]])\neta = 0.02\ndef rule_from_thetas(thetas):\n    return PR.Plasticity_Rule([Region('N', (-np.inf, thetas[0]), 0.5, 0),\n                              Region('D', (thetas[0], thetas[1]), 0, eta),\n                              Region('P', (thetas[1], np.inf), 0.5, eta)])\nrules = [rule_from_thetas(thetas) for thetas in all_thetas]\nrule_names = ['P supervisor\\n(Global)', 'P supervisor\\n(Targeted)', 'P&D supervisors\\n(Global)', 'P&D supervisors\\n(Targeted)']\ninput_bars = [0, 0, 0, 1, 1, 1]\noutput_bars = [1, 2, 3, 1, 2, 3]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "eta = 0.02\ndef rule_from_thetas(thetas):\n    return PR.Plasticity_Rule([Region('N', (-np.inf, thetas[0]), 0.5, 0),\n                              Region('D', (thetas[0], thetas[1]), 0, eta),\n                              Region('P', (thetas[1], np.inf), 0.5, eta)])\nrules = [rule_from_thetas(thetas) for thetas in all_thetas]\nrule_names = ['P supervisor\\n(Global)', 'P supervisor\\n(Targeted)', 'P&D supervisors\\n(Global)', 'P&D supervisors\\n(Targeted)']\ninput_bars = [0, 0, 0, 1, 1, 1]\noutput_bars = [1, 2, 3, 1, 2, 3]\nZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "rules",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "rules = [rule_from_thetas(thetas) for thetas in all_thetas]\nrule_names = ['P supervisor\\n(Global)', 'P supervisor\\n(Targeted)', 'P&D supervisors\\n(Global)', 'P&D supervisors\\n(Targeted)']\ninput_bars = [0, 0, 0, 1, 1, 1]\noutput_bars = [1, 2, 3, 1, 2, 3]\nZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]\nZPs = [all_thetas[0][1]+eps,\n       all_thetas[1][1]-all_coeffs[1][0],\n       all_thetas[2][1]+eps,\n       all_thetas[3][1]-all_coeffs[3][0]+eps]\nall_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "rule_names",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "rule_names = ['P supervisor\\n(Global)', 'P supervisor\\n(Targeted)', 'P&D supervisors\\n(Global)', 'P&D supervisors\\n(Targeted)']\ninput_bars = [0, 0, 0, 1, 1, 1]\noutput_bars = [1, 2, 3, 1, 2, 3]\nZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]\nZPs = [all_thetas[0][1]+eps,\n       all_thetas[1][1]-all_coeffs[1][0],\n       all_thetas[2][1]+eps,\n       all_thetas[3][1]-all_coeffs[3][0]+eps]\nall_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]\nmin_target = 1",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "input_bars",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "input_bars = [0, 0, 0, 1, 1, 1]\noutput_bars = [1, 2, 3, 1, 2, 3]\nZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]\nZPs = [all_thetas[0][1]+eps,\n       all_thetas[1][1]-all_coeffs[1][0],\n       all_thetas[2][1]+eps,\n       all_thetas[3][1]-all_coeffs[3][0]+eps]\nall_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]\nmin_target = 1\nmax_target = 3",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "output_bars",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "output_bars = [1, 2, 3, 1, 2, 3]\nZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]\nZPs = [all_thetas[0][1]+eps,\n       all_thetas[1][1]-all_coeffs[1][0],\n       all_thetas[2][1]+eps,\n       all_thetas[3][1]-all_coeffs[3][0]+eps]\nall_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]\nmin_target = 1\nmax_target = 3\nall_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "ZDs",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "ZDs = [0,0,all_thetas[2][0]+eps, all_thetas[3][0]+eps-all_coeffs[3][0]]\nZPs = [all_thetas[0][1]+eps,\n       all_thetas[1][1]-all_coeffs[1][0],\n       all_thetas[2][1]+eps,\n       all_thetas[3][1]-all_coeffs[3][0]+eps]\nall_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]\nmin_target = 1\nmax_target = 3\nall_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]\nN = 20",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "ZPs",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "ZPs = [all_thetas[0][1]+eps,\n       all_thetas[1][1]-all_coeffs[1][0],\n       all_thetas[2][1]+eps,\n       all_thetas[3][1]-all_coeffs[3][0]+eps]\nall_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]\nmin_target = 1\nmax_target = 3\nall_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]\nN = 20\nP = 50",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "all_Zs",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "all_Zs = [[ZPs[j] if i in (0,3) else ZDs[j] if i in (2,5) else 0 for i in range(6) ] for j in range(4)]\nmin_target = 1\nmax_target = 3\nall_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]\nN = 20\nP = 50\nseed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "min_target",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "min_target = 1\nmax_target = 3\nall_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]\nN = 20\nP = 50\nseed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "max_target",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "max_target = 3\nall_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]\nN = 20\nP = 50\nseed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "all_supervisors",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "all_supervisors = [cs.homeostatic_supervisorPD(min_target=min_target, max_target = max_target, Z_p = ZPs[i], Z_d=ZDs[i]) for i in range(4)]\nN = 20\nP = 50\nseed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "N = 20\nP = 50\nseed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "P = 50\nseed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "seed",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "seed = 50\n#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "#patterns_targeted",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "#patterns_targeted = [pg.pattern_gen(N, 1, density) for density in [0.15,0.8]]\nevens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "evens",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "evens = np.array([1 if number % 2 == 0 else 0 for number in range(N)])\nodds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "odds",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "odds = 1 - evens\npatterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)\n# bar_names = [[r\"$\\hat{y}$\" + f\"={output_bars[i]}\\n\"",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "patterns_targeted",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "patterns_targeted = [evens, odds]\nweights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)\n# bar_names = [[r\"$\\hat{y}$\" + f\"={output_bars[i]}\\n\"\n#                               + r\"$\\mathregular{x_{i}}$=\"",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "weights_targeted",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "weights_targeted = 0.05 * evens + 0.4 * odds\npattern_nums, inputs_targeted = pg.pattern_mixer(patterns_targeted, 80, seed = seed)\ninputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)\n# bar_names = [[r\"$\\hat{y}$\" + f\"={output_bars[i]}\\n\"\n#                               + r\"$\\mathregular{x_{i}}$=\"\n#                               + f\"{input_bars[i]}\"",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "inputs_global",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "inputs_global = np.vstack((pg.pattern_gen(N, int(P/2), 0.15) ,pg.pattern_gen(N, int(P/2), 0.5)))\n(inputs_global)\nlocal_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)\n# bar_names = [[r\"$\\hat{y}$\" + f\"={output_bars[i]}\\n\"\n#                               + r\"$\\mathregular{x_{i}}$=\"\n#                               + f\"{input_bars[i]}\"\n#                               + f\"\\nZ={np.round(all_Zs[j][i],2)}\" for\n#                               i in range(6)] for j in range(num_rules)]",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "local_inputs",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "local_inputs = [inputs_targeted, inputs_targeted, inputs_targeted, inputs_targeted]\nall_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)\n# bar_names = [[r\"$\\hat{y}$\" + f\"={output_bars[i]}\\n\"\n#                               + r\"$\\mathregular{x_{i}}$=\"\n#                               + f\"{input_bars[i]}\"\n#                               + f\"\\nZ={np.round(all_Zs[j][i],2)}\" for\n#                               i in range(6)] for j in range(num_rules)]\n# (bar_names)\nbar_names = [[(r\"$\\hat{y}=$\" if i == 0 else \"\")",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "all_bars",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "all_bars = [[input_bars, output_bars, all_Zs[i]] for i in range(num_rules)]\n# (all_Zs)\n# bar_names = [[r\"$\\hat{y}$\" + f\"={output_bars[i]}\\n\"\n#                               + r\"$\\mathregular{x_{i}}$=\"\n#                               + f\"{input_bars[i]}\"\n#                               + f\"\\nZ={np.round(all_Zs[j][i],2)}\" for\n#                               i in range(6)] for j in range(num_rules)]\n# (bar_names)\nbar_names = [[(r\"$\\hat{y}=$\" if i == 0 else \"\")\n              + f\"{output_bars[i]}\\n\"",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "bar_names",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "bar_names = [[(r\"$\\hat{y}=$\" if i == 0 else \"\")\n              + f\"{output_bars[i]}\\n\"\n              + (r\"$\\mathregular{x_{i}}$=\" if i == 0 else \"\")\n              + (f\"{input_bars[i]}\\n\")\n              + (\"Z=\" if i == 0 else \"\")\n              +(f\"{np.round(all_Zs[j][i],2)}\")\n              for i in range(6)] for j in range(num_rules)]\ncalcitrons = [Calcitron(all_coeffs[i],\n                        rules[i],\n                        supervisor=all_supervisors[i],",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "calcitrons",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "calcitrons = [Calcitron(all_coeffs[i],\n                        rules[i],\n                        supervisor=all_supervisors[i],\n                        activation_function='linear') for i in range(len(rules))]\nfig, bar_subplots, results_subplots = rcg.rule_comparison_grid(calcitrons, rule_names, all_bars, bar_names,\n                                                               local_inputs, coeffs_to_use=[0, 2, 3], show_supervisor=1,\n                                                               w_init=weights_targeted, plot_cbar=[3], figsize = (8.2, 8))\nfor ax in bar_subplots:\n    ax.set_xticklabels(labels = ax.get_xticklabels(), fontsize = 7)\n    xtick_positions = ax.get_xticks()",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "fig.axes[0].legend(bbox_to_anchor",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "fig.axes[0].legend(bbox_to_anchor = (-0.18, 1.5))\n# pattern_labels = 'E'\n# for ax in np.array(results_subplots).ravel():\n#     ax.set_xticks(range(len(pattern_nums)), labels = ['O' if pattern_num else 'E'  for pattern_num in pattern_nums], fontsize = 4)\nletters = ['B','C','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,8)]).ravel()\nph.label_panels(fig, labels = labels, size = 8)\nplt.savefig(constants.PLOT_FOLDER + '7.svg', dpi=fig.dpi)\nplt.show()\nparam_helpers.fig_params(calcitrons, letters, 7)",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "letters = ['B','C','E','F']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,8)]).ravel()\nph.label_panels(fig, labels = labels, size = 8)\nplt.savefig(constants.PLOT_FOLDER + '7.svg', dpi=fig.dpi)\nplt.show()\nparam_helpers.fig_params(calcitrons, letters, 7)",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "Fig7_homeostatic",
        "description": "Fig7_homeostatic",
        "peekOfCode": "labels = np.array([[letter + str(j) for letter in letters] for j in range(1,8)]).ravel()\nph.label_panels(fig, labels = labels, size = 8)\nplt.savefig(constants.PLOT_FOLDER + '7.svg', dpi=fig.dpi)\nplt.show()\nparam_helpers.fig_params(calcitrons, letters, 7)",
        "detail": "Fig7_homeostatic",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "P = 6\nsparsity = 0.25\nN = 24\nfp = 0\nfd = 1\nepochs = 10\neta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "sparsity",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "sparsity = 0.25\nN = 24\nfp = 0\nfd = 1\nepochs = 10\neta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "N = 24\nfp = 0\nfd = 1\nepochs = 10\neta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "fp",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "fp = 0\nfd = 1\nepochs = 10\neta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)\n# Create a dictionary to map each pattern to its corresponding label",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "fd",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "fd = 1\nepochs = 10\neta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)\n# Create a dictionary to map each pattern to its corresponding label\nlabel_dict = {tuple(X[i]): y[i] for i in range(len(X))}",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "epochs",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "epochs = 10\neta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)\n# Create a dictionary to map each pattern to its corresponding label\nlabel_dict = {tuple(X[i]): y[i] for i in range(len(X))}\n# Create a list of pattern numbers, each repeated for the specified number of epochs",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "eta = 0.2\nseed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)\n# Create a dictionary to map each pattern to its corresponding label\nlabel_dict = {tuple(X[i]): y[i] for i in range(len(X))}\n# Create a list of pattern numbers, each repeated for the specified number of epochs\nnumbers = np.array([rng.permutation(P) for _ in range(epochs)]).flatten()",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "seed",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "seed = 100950\n# good seed = 100950\nrng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)\n# Create a dictionary to map each pattern to its corresponding label\nlabel_dict = {tuple(X[i]): y[i] for i in range(len(X))}\n# Create a list of pattern numbers, each repeated for the specified number of epochs\nnumbers = np.array([rng.permutation(P) for _ in range(epochs)]).flatten()\n# Create the shuffled patterns and labels",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "rng",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "rng = np.random.default_rng(seed)\n# Generate the perceptron patterns\nX, y = pg.generate_perceptron_patterns(P, N, sparsity, seed=seed)\n# Create a dictionary to map each pattern to its corresponding label\nlabel_dict = {tuple(X[i]): y[i] for i in range(len(X))}\n# Create a list of pattern numbers, each repeated for the specified number of epochs\nnumbers = np.array([rng.permutation(P) for _ in range(epochs)]).flatten()\n# Create the shuffled patterns and labels\npatterns = np.array([X[num] for num in numbers])\nlabels = np.array([label_dict[tuple(X[num])] for num in numbers])",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "label_dict",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "label_dict = {tuple(X[i]): y[i] for i in range(len(X))}\n# Create a list of pattern numbers, each repeated for the specified number of epochs\nnumbers = np.array([rng.permutation(P) for _ in range(epochs)]).flatten()\n# Create the shuffled patterns and labels\npatterns = np.array([X[num] for num in numbers])\nlabels = np.array([label_dict[tuple(X[num])] for num in numbers])\n# Print the patterns\nprint(patterns)\nbias = -0.5 * ((N * sparsity * fp) +\n                         (N * sparsity * fd))",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "numbers = np.array([rng.permutation(P) for _ in range(epochs)]).flatten()\n# Create the shuffled patterns and labels\npatterns = np.array([X[num] for num in numbers])\nlabels = np.array([label_dict[tuple(X[num])] for num in numbers])\n# Print the patterns\nprint(patterns)\nbias = -0.5 * ((N * sparsity * fp) +\n                         (N * sparsity * fd))\ntarget_rule = Plasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                 Region(name='D', bounds=(0.5, 0.6), fp=0, eta=eta, fp_color='b', bar_code_color='b'),",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "patterns = np.array([X[num] for num in numbers])\nlabels = np.array([label_dict[tuple(X[num])] for num in numbers])\n# Print the patterns\nprint(patterns)\nbias = -0.5 * ((N * sparsity * fp) +\n                         (N * sparsity * fd))\ntarget_rule = Plasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                 Region(name='D', bounds=(0.5, 0.6), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n                 Region(name='P', bounds=(0.6, 0.8), fp=1, eta=eta, fp_color='r', bar_code_color='r'),\n                 Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='w')])",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "labels = np.array([label_dict[tuple(X[num])] for num in numbers])\n# Print the patterns\nprint(patterns)\nbias = -0.5 * ((N * sparsity * fp) +\n                         (N * sparsity * fd))\ntarget_rule = Plasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                 Region(name='D', bounds=(0.5, 0.6), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n                 Region(name='P', bounds=(0.6, 0.8), fp=1, eta=eta, fp_color='r', bar_code_color='r'),\n                 Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='w')])\ntarget_coeffs = [0.45, 0, 0.1, 1]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "bias",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "bias = -0.5 * ((N * sparsity * fp) +\n                         (N * sparsity * fd))\ntarget_rule = Plasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                 Region(name='D', bounds=(0.5, 0.6), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n                 Region(name='P', bounds=(0.6, 0.8), fp=1, eta=eta, fp_color='r', bar_code_color='r'),\n                 Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='w')])\ntarget_coeffs = [0.45, 0, 0.1, 1]\nx_bar = [\"local\", \"BAP\", \"$Z_P$\",\n         \"BAP+\\n$Z_P$\",\n         \"local+\\nBAP\", \"local+$Z_P$\",",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "target_rule",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "target_rule = Plasticity_Rule([Region(name='N', bounds=(-np.inf, 0.5), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n                 Region(name='D', bounds=(0.5, 0.6), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n                 Region(name='P', bounds=(0.6, 0.8), fp=1, eta=eta, fp_color='r', bar_code_color='r'),\n                 Region(name='PPNZ', bounds=(0.8, np.inf), fp=0.25, eta=0, fp_color='g', bar_code_color='w')])\ntarget_coeffs = [0.45, 0, 0.1, 1]\nx_bar = [\"local\", \"BAP\", \"$Z_P$\",\n         \"BAP+\\n$Z_P$\",\n         \"local+\\nBAP\", \"local+$Z_P$\",\n         \"local\\nBAP+$Z_P$\"]\nalpha_vector = np.array([1, 0, 0, 0, 1, 1, 1])",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "target_coeffs",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "target_coeffs = [0.45, 0, 0.1, 1]\nx_bar = [\"local\", \"BAP\", \"$Z_P$\",\n         \"BAP+\\n$Z_P$\",\n         \"local+\\nBAP\", \"local+$Z_P$\",\n         \"local\\nBAP+$Z_P$\"]\nalpha_vector = np.array([1, 0, 0, 0, 1, 1, 1])\n# beta_vector = np.array([0, 0, 0, 0, 0, 0, 0])\ngamma_vector = np.array([0, 1, 0, 1, 1, 0, 1])\ndelta_vector = np.array([0, 0, 0.3, 0.3, 0, 0.3, 0.3])\ntarget_bar_matrix = [alpha_vector, gamma_vector, delta_vector]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "x_bar",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "x_bar = [\"local\", \"BAP\", \"$Z_P$\",\n         \"BAP+\\n$Z_P$\",\n         \"local+\\nBAP\", \"local+$Z_P$\",\n         \"local\\nBAP+$Z_P$\"]\nalpha_vector = np.array([1, 0, 0, 0, 1, 1, 1])\n# beta_vector = np.array([0, 0, 0, 0, 0, 0, 0])\ngamma_vector = np.array([0, 1, 0, 1, 1, 0, 1])\ndelta_vector = np.array([0, 0, 0.3, 0.3, 0, 0.3, 0.3])\ntarget_bar_matrix = [alpha_vector, gamma_vector, delta_vector]\ntarget_calc = Calcitron(target_coeffs, target_rule, supervisor = sprvs.target_perceptron_supervisor(0.3, X,y), bias = bias)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "alpha_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "alpha_vector = np.array([1, 0, 0, 0, 1, 1, 1])\n# beta_vector = np.array([0, 0, 0, 0, 0, 0, 0])\ngamma_vector = np.array([0, 1, 0, 1, 1, 0, 1])\ndelta_vector = np.array([0, 0, 0.3, 0.3, 0, 0.3, 0.3])\ntarget_bar_matrix = [alpha_vector, gamma_vector, delta_vector]\ntarget_calc = Calcitron(target_coeffs, target_rule, supervisor = sprvs.target_perceptron_supervisor(0.3, X,y), bias = bias)\n#Section 2 critic perceptron\ncritic_rule = Plasticity_Rule(\n    [Region(name='N', bounds=(-np.inf, 0.6), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n     Region(name='D', bounds=(0.6, 0.9), fp=0, eta=eta, fp_color='b', bar_code_color='b'),",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "gamma_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "gamma_vector = np.array([0, 1, 0, 1, 1, 0, 1])\ndelta_vector = np.array([0, 0, 0.3, 0.3, 0, 0.3, 0.3])\ntarget_bar_matrix = [alpha_vector, gamma_vector, delta_vector]\ntarget_calc = Calcitron(target_coeffs, target_rule, supervisor = sprvs.target_perceptron_supervisor(0.3, X,y), bias = bias)\n#Section 2 critic perceptron\ncritic_rule = Plasticity_Rule(\n    [Region(name='N', bounds=(-np.inf, 0.6), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n     Region(name='D', bounds=(0.6, 0.9), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n     Region(name='P', bounds=(0.9, np.inf), fp=1, eta=eta, fp_color='r', bar_code_color='r')])\nZ_d = 0.2",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "delta_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "delta_vector = np.array([0, 0, 0.3, 0.3, 0, 0.3, 0.3])\ntarget_bar_matrix = [alpha_vector, gamma_vector, delta_vector]\ntarget_calc = Calcitron(target_coeffs, target_rule, supervisor = sprvs.target_perceptron_supervisor(0.3, X,y), bias = bias)\n#Section 2 critic perceptron\ncritic_rule = Plasticity_Rule(\n    [Region(name='N', bounds=(-np.inf, 0.6), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n     Region(name='D', bounds=(0.6, 0.9), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n     Region(name='P', bounds=(0.9, np.inf), fp=1, eta=eta, fp_color='r', bar_code_color='r')])\nZ_d = 0.2\nZ_p = 0.5",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "target_bar_matrix",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "target_bar_matrix = [alpha_vector, gamma_vector, delta_vector]\ntarget_calc = Calcitron(target_coeffs, target_rule, supervisor = sprvs.target_perceptron_supervisor(0.3, X,y), bias = bias)\n#Section 2 critic perceptron\ncritic_rule = Plasticity_Rule(\n    [Region(name='N', bounds=(-np.inf, 0.6), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n     Region(name='D', bounds=(0.6, 0.9), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n     Region(name='P', bounds=(0.9, np.inf), fp=1, eta=eta, fp_color='r', bar_code_color='r')])\nZ_d = 0.2\nZ_p = 0.5\nx_bar_critic_perceptron = [\"local\", r'$Z_D$', r'$Z_P$',",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "target_calc",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "target_calc = Calcitron(target_coeffs, target_rule, supervisor = sprvs.target_perceptron_supervisor(0.3, X,y), bias = bias)\n#Section 2 critic perceptron\ncritic_rule = Plasticity_Rule(\n    [Region(name='N', bounds=(-np.inf, 0.6), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n     Region(name='D', bounds=(0.6, 0.9), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n     Region(name='P', bounds=(0.9, np.inf), fp=1, eta=eta, fp_color='r', bar_code_color='r')])\nZ_d = 0.2\nZ_p = 0.5\nx_bar_critic_perceptron = [\"local\", r'$Z_D$', r'$Z_P$',\n                            'local+\\n' +r'$Z_D$', r'local' + '\\n$Z_P$']",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "critic_rule",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "critic_rule = Plasticity_Rule(\n    [Region(name='N', bounds=(-np.inf, 0.6), fp=0.25, eta=0, fp_color='k', bar_code_color='w'),\n     Region(name='D', bounds=(0.6, 0.9), fp=0, eta=eta, fp_color='b', bar_code_color='b'),\n     Region(name='P', bounds=(0.9, np.inf), fp=1, eta=eta, fp_color='r', bar_code_color='r')])\nZ_d = 0.2\nZ_p = 0.5\nx_bar_critic_perceptron = [\"local\", r'$Z_D$', r'$Z_P$',\n                            'local+\\n' +r'$Z_D$', r'local' + '\\n$Z_P$']\ncritic_coeffs = [0.45, 0, 0, 1]\ncp_alpha_vector = np.array([1, 0, 0, 1, 1])",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "Z_d",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "Z_d = 0.2\nZ_p = 0.5\nx_bar_critic_perceptron = [\"local\", r'$Z_D$', r'$Z_P$',\n                            'local+\\n' +r'$Z_D$', r'local' + '\\n$Z_P$']\ncritic_coeffs = [0.45, 0, 0, 1]\ncp_alpha_vector = np.array([1, 0, 0, 1, 1])\ncp_beta_vector = np.zeros(len(x_bar_critic_perceptron))\ncp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "Z_p",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "Z_p = 0.5\nx_bar_critic_perceptron = [\"local\", r'$Z_D$', r'$Z_P$',\n                            'local+\\n' +r'$Z_D$', r'local' + '\\n$Z_P$']\ncritic_coeffs = [0.45, 0, 0, 1]\ncp_alpha_vector = np.array([1, 0, 0, 1, 1])\ncp_beta_vector = np.zeros(len(x_bar_critic_perceptron))\ncp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "x_bar_critic_perceptron",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "x_bar_critic_perceptron = [\"local\", r'$Z_D$', r'$Z_P$',\n                            'local+\\n' +r'$Z_D$', r'local' + '\\n$Z_P$']\ncritic_coeffs = [0.45, 0, 0, 1]\ncp_alpha_vector = np.array([1, 0, 0, 1, 1])\ncp_beta_vector = np.zeros(len(x_bar_critic_perceptron))\ncp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "critic_coeffs",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "critic_coeffs = [0.45, 0, 0, 1]\ncp_alpha_vector = np.array([1, 0, 0, 1, 1])\ncp_beta_vector = np.zeros(len(x_bar_critic_perceptron))\ncp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "cp_alpha_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "cp_alpha_vector = np.array([1, 0, 0, 1, 1])\ncp_beta_vector = np.zeros(len(x_bar_critic_perceptron))\ncp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "cp_beta_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "cp_beta_vector = np.zeros(len(x_bar_critic_perceptron))\ncp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "cp_gamma_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "cp_gamma_vector =  np.zeros(len(x_bar_critic_perceptron))\ncp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "cp_Zd_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "cp_Zd_vector = np.array([0, 1, 0, 1, 0]) * Z_d\ncp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "cp_Zp_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "cp_Zp_vector = np.array([0, 0, 1, 0, 1]) * Z_p\ncp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "cp_Z_vector",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "cp_Z_vector = cp_Zp_vector + cp_Zd_vector\ncritic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "critic_bar_matrix",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "critic_bar_matrix = [cp_alpha_vector, np.zeros(len(x_bar_critic_perceptron)), cp_Z_vector]\ncritic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "critic_perceptron_calc",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "critic_perceptron_calc = Calcitron(critic_coeffs, critic_rule,\n                                   supervisor=sprvs.critic_perceptron_supervisor(Z_d, Z_p, X, y), bias = bias)\ncalcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))\nfor ax in np.array(results_subplots).ravel():",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "calcitrons",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "calcitrons = [target_calc, critic_perceptron_calc]\ntitles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))\nfor ax in np.array(results_subplots).ravel():\n    ax.set_xticks(range(len(patterns)), labels = [label_dict[tuple(pattern)] for pattern in patterns], size = 8)\nnp.array(results_subplots)[5][0].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "titles",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "titles = [\"Target Perceptron\", \"Critic Perceptron\"]\nall_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))\nfor ax in np.array(results_subplots).ravel():\n    ax.set_xticks(range(len(patterns)), labels = [label_dict[tuple(pattern)] for pattern in patterns], size = 8)\nnp.array(results_subplots)[5][0].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][1].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "all_bar_mats",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "all_bar_mats = [target_bar_matrix, critic_bar_matrix]\nx_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))\nfor ax in np.array(results_subplots).ravel():\n    ax.set_xticks(range(len(patterns)), labels = [label_dict[tuple(pattern)] for pattern in patterns], size = 8)\nnp.array(results_subplots)[5][0].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][1].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][0].set_xlabel('label\\npattern #')",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "x_barplot",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "x_barplot = [x_bar, x_bar_critic_perceptron]\nall_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))\nfor ax in np.array(results_subplots).ravel():\n    ax.set_xticks(range(len(patterns)), labels = [label_dict[tuple(pattern)] for pattern in patterns], size = 8)\nnp.array(results_subplots)[5][0].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][1].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][0].set_xlabel('label\\npattern #')\nnp.array(results_subplots)[5][1].set_xlabel('label\\npattern #')",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "all_local_inputs",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "all_local_inputs = [patterns, patterns]\nfig, bar_subplots, results_subplots = \\\n    rcg.rule_comparison_grid(calcitrons, titles, all_bar_mats, x_barplot, all_local_inputs, show_supervisor=1, coeffs_to_use = [0,2,3], plot_cbar = [1], figsize = (8,8))\nfor ax in np.array(results_subplots).ravel():\n    ax.set_xticks(range(len(patterns)), labels = [label_dict[tuple(pattern)] for pattern in patterns], size = 8)\nnp.array(results_subplots)[5][0].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][1].set_xticks(range(len(patterns)), labels = [str(label_dict[tuple(patterns[i])]) + '\\n' + str(numbers[i]) for i in range(len(patterns))])\nnp.array(results_subplots)[5][0].set_xlabel('label\\npattern #')\nnp.array(results_subplots)[5][1].set_xlabel('label\\npattern #')\nletters = ['B','D']",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "letters = ['B','D']\nlabels = np.array([[letter + str(j) for letter in letters] for j in range(1,8)]).ravel()\nph.label_panels(fig, labels = labels, size = 8)\nfor ax in fig.axes:\n    ax.tick_params(axis='both', labelsize=6)\nfig.axes[0].legend(bbox_to_anchor = (-0.11, 1.5))\nplt.savefig(constants.PLOT_FOLDER + '8.svg', dpi=fig.dpi)\nparam_helpers.fig_params(calcitrons, ['B','D'], 8)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "labels = np.array([[letter + str(j) for letter in letters] for j in range(1,8)]).ravel()\nph.label_panels(fig, labels = labels, size = 8)\nfor ax in fig.axes:\n    ax.tick_params(axis='both', labelsize=6)\nfig.axes[0].legend(bbox_to_anchor = (-0.11, 1.5))\nplt.savefig(constants.PLOT_FOLDER + '8.svg', dpi=fig.dpi)\nparam_helpers.fig_params(calcitrons, ['B','D'], 8)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "fig.axes[0].legend(bbox_to_anchor",
        "kind": 5,
        "importPath": "Fig8_perceptrons",
        "description": "Fig8_perceptrons",
        "peekOfCode": "fig.axes[0].legend(bbox_to_anchor = (-0.11, 1.5))\nplt.savefig(constants.PLOT_FOLDER + '8.svg', dpi=fig.dpi)\nparam_helpers.fig_params(calcitrons, ['B','D'], 8)",
        "detail": "Fig8_perceptrons",
        "documentation": {}
    },
    {
        "label": "latex_to_unicode",
        "kind": 2,
        "importPath": "param_helpers",
        "description": "param_helpers",
        "peekOfCode": "def latex_to_unicode(latex_list):\n    # Dictionary mapping LaTeX symbols to Unicode\n    latex_to_unicode_dict = {\n        r'\\theta_{D}': 'θ_D',\n        r'\\F_{D}': 'F_D',\n        r'\\eta_{D}': 'η_D',\n        r'\\theta_{P}': 'θ_P',\n        r'\\F_{P}': 'F_P',\n        r'\\eta_{P}': 'η_P',\n        r'\\theta_{PPNZ}': 'η_PPNZ',",
        "detail": "param_helpers",
        "documentation": {}
    },
    {
        "label": "coeffs_to_pandas",
        "kind": 2,
        "importPath": "param_helpers",
        "description": "param_helpers",
        "peekOfCode": "def coeffs_to_pandas(coeffs):\n    df = pd.DataFrame(coeffs, index=['α', 'β', 'γ', 'δ']).T\n    df.columns = latex_to_unicode(df.columns)\n    return df\ndef fig_params(rules, rule_names, fig_num, coeffs=None):\n    mydf = pd.DataFrame()\n    # Check if coeffs is None\n    if coeffs is None:\n        zipped = zip(rules, rule_names)\n    else:",
        "detail": "param_helpers",
        "documentation": {}
    },
    {
        "label": "fig_params",
        "kind": 2,
        "importPath": "param_helpers",
        "description": "param_helpers",
        "peekOfCode": "def fig_params(rules, rule_names, fig_num, coeffs=None):\n    mydf = pd.DataFrame()\n    # Check if coeffs is None\n    if coeffs is None:\n        zipped = zip(rules, rule_names)\n    else:\n        zipped = zip(rules, rule_names, coeffs)\n    print(zipped.__str__())\n    for values in zipped:\n        if coeffs is None:",
        "detail": "param_helpers",
        "documentation": {}
    },
    {
        "label": "param_concat",
        "kind": 2,
        "importPath": "param_helpers",
        "description": "param_helpers",
        "peekOfCode": "def param_concat():\n    df = pd.DataFrame()\n    # Initialize an empty list to store the DataFrames\n    dfs = []\n    # Loop over the file numbers\n    for i in range(1, 9):  # Replace n with the number of files\n        # Read the CSV file into a DataFrame\n        if not i in [3]:\n            df_temp = pd.read_csv(constants.PARAMS_FOLDER + f'fig{i}_params.csv')\n            # Create a DataFrame with a single row containing the figure number",
        "detail": "param_helpers",
        "documentation": {}
    },
    {
        "label": "noisify",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def noisify(pattern, flip_prob=0.1, seed=1):\n    rng = np.random.default_rng(seed)\n    return np.array([bit if (rng.random() > flip_prob) else 1 - bit for bit in pattern])\ndef signal_noise_gen_old(patterns, pattern_probs, P, flip_prob, seed=1):\n    rng = np.random.default_rng(seed)\n    patterns = np.atleast_2d(patterns)\n    patterns = np.vstack([np.zeros_like(patterns[0]), patterns])  # add the empty pattern\n    pattern_probs = pattern_probs.append(1 - np.sum(pattern_probs))\n    draw = rng.choice(range(len(patterns)), P, p=pattern_probs)\n    noised_draw = np.array([noisify(patterns[i], flip_prob, seed) if i == 0 else patterns[i] for i in draw])",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "signal_noise_gen_old",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def signal_noise_gen_old(patterns, pattern_probs, P, flip_prob, seed=1):\n    rng = np.random.default_rng(seed)\n    patterns = np.atleast_2d(patterns)\n    patterns = np.vstack([np.zeros_like(patterns[0]), patterns])  # add the empty pattern\n    pattern_probs = pattern_probs.append(1 - np.sum(pattern_probs))\n    draw = rng.choice(range(len(patterns)), P, p=pattern_probs)\n    noised_draw = np.array([noisify(patterns[i], flip_prob, seed) if i == 0 else patterns[i] for i in draw])\n    return noised_draw\ndef pattern_gen(N, P, density, seed=1):\n    rng = np.random.default_rng(seed)",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "pattern_gen",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def pattern_gen(N, P, density, seed=1):\n    rng = np.random.default_rng(seed)\n    pos_N = int(density * N)\n    neg_N = N - pos_N\n    return np.squeeze([rng.permutation([0] * neg_N + [1] * pos_N) for i in range(P)])\ndef signal_noise_gen(N, P, signal_prob, density, seed=1):\n    rng = np.random.default_rng(seed)\n    signal_pattern = pattern_gen(N, 1, density, seed)\n    pattern_probs = [1 - signal_prob, signal_prob]\n    draw = rng.choice(range(2), P, p=pattern_probs)",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "signal_noise_gen",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def signal_noise_gen(N, P, signal_prob, density, seed=1):\n    rng = np.random.default_rng(seed)\n    signal_pattern = pattern_gen(N, 1, density, seed)\n    pattern_probs = [1 - signal_prob, signal_prob]\n    draw = rng.choice(range(2), P, p=pattern_probs)\n    input_patterns = np.squeeze([pattern_gen(N, 1, density, seed = None) if i == 0 else signal_pattern for i in draw])\n    return signal_pattern, draw, input_patterns\ndef random_inputs_all(N, P, seed=1):\n    rng = np.random.default_rng(seed)\n    pattern3 = rng.permutation([0] * int(0.75 * N) + [1] * int(0.25 * N))",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "random_inputs_all",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def random_inputs_all(N, P, seed=1):\n    rng = np.random.default_rng(seed)\n    pattern3 = rng.permutation([0] * int(0.75 * N) + [1] * int(0.25 * N))\n    pattern2 = rng.permutation([0] * int(0.92 * N) + [1] * int(0.08 * N))\n    pattern1 = rng.permutation([0] * int(0.95 * N) + [1] * int(0.05 * N))\n    patterns = [pattern1, pattern2, pattern3]\n    probs = [0.4, 0.3, 0.3]\n    pat_nums = rng.permutation(sum([[i] * int(probs[i] * P) for i in range(len(patterns))], []))\n    local_inputs = [patterns[pat_nums[i]] for i in range(P)]\n    return pat_nums, local_inputs",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "pattern_mixer",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def pattern_mixer(patterns, P, pattern_probs=None, seed=1):\n    rng = np.random.default_rng(seed)\n    pattern_nums = rng.choice(range(len(patterns)), P, p=pattern_probs)\n    local_inputs = np.array([patterns[i] for i in pattern_nums])\n    return pattern_nums, np.squeeze(local_inputs)\ndef generate_perceptron_patterns(P, N, sparsity, seed=1):\n    rng = random.Random(seed)\n    patterns = []\n    for i in range(P):\n        pattern = [1 if rng.random() < sparsity else 0 for _ in range(N)]",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "generate_perceptron_patterns",
        "kind": 2,
        "importPath": "pattern_generators",
        "description": "pattern_generators",
        "peekOfCode": "def generate_perceptron_patterns(P, N, sparsity, seed=1):\n    rng = random.Random(seed)\n    patterns = []\n    for i in range(P):\n        pattern = [1 if rng.random() < sparsity else 0 for _ in range(N)]\n        patterns.append(pattern)\n    labels = [1] * int(P/2) + [0] * int(P/2)\n    rng.shuffle(labels)\n    return patterns, labels",
        "detail": "pattern_generators",
        "documentation": {}
    },
    {
        "label": "label_perceptron",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "label_perceptron = {r'$\\alpha$':0.45, r'$\\gamma$':0.1, r'$\\delta$':0.3,'theta_d': 0.5, 'theta_p': 0.6, 'theta_ppnz':0.8}\neta = 0.0003\nf_d = -1\nf_p = 1\ntheta_d = label_perceptron[\"theta_d\"]\ntheta_p = label_perceptron[\"theta_p\"]\ntheta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "eta",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "eta = 0.0003\nf_d = -1\nf_p = 1\ntheta_d = label_perceptron[\"theta_d\"]\ntheta_p = label_perceptron[\"theta_p\"]\ntheta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "f_d",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "f_d = -1\nf_p = 1\ntheta_d = label_perceptron[\"theta_d\"]\ntheta_p = label_perceptron[\"theta_p\"]\ntheta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}\nlabel_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "f_p",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "f_p = 1\ntheta_d = label_perceptron[\"theta_d\"]\ntheta_p = label_perceptron[\"theta_p\"]\ntheta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}\nlabel_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}\nplot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "theta_d",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "theta_d = label_perceptron[\"theta_d\"]\ntheta_p = label_perceptron[\"theta_p\"]\ntheta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}\nlabel_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}\nplot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN = 100",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "theta_p",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "theta_p = label_perceptron[\"theta_p\"]\ntheta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}\nlabel_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}\nplot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN = 100\nP = 100",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "theta_ppnz",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "theta_ppnz = label_perceptron[\"theta_ppnz\"]\neta_dict_label_perceptron= {(-np.inf,theta_d):0, (theta_d,theta_p):eta,\n                (theta_p,theta_ppnz):eta, (theta_ppnz, np.inf): 0}\nFP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}\nlabel_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}\nplot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN = 100\nP = 100\nlocal_inputs = [np.random.randint(2, size=P) for n in range(N)]",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "FP_dict_label_perceptron",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "FP_dict_label_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d,\n               (theta_p,theta_ppnz):f_p, (theta_ppnz,np.inf):0.25}\nlabel_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}\nplot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN = 100\nP = 100\nlocal_inputs = [np.random.randint(2, size=P) for n in range(N)]\ninit_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "label_perceptron_param_dict",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "label_perceptron_param_dict = {\"eta_dict\":eta_dict_label_perceptron, \"FP_dict\":FP_dict_label_perceptron,\"soft_threshold\": 0}\nplot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN = 100\nP = 100\nlocal_inputs = [np.random.randint(2, size=P) for n in range(N)]\ninit_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "plot_dict_label",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "plot_dict_label = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN = 100\nP = 100\nlocal_inputs = [np.random.randint(2, size=P) for n in range(N)]\ninit_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "N = 100\nP = 100\nlocal_inputs = [np.random.randint(2, size=P) for n in range(N)]\ninit_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "P = 100\nlocal_inputs = [np.random.randint(2, size=P) for n in range(N)]\ninit_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "local_inputs",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "local_inputs = [np.random.randint(2, size=P) for n in range(N)]\ninit_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)\nax_label_perceptron = label_perceptron_calc.ax",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "init_weights_label",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "init_weights_label = np.random.uniform(f_d, f_p+0.1, N)\n#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)\nax_label_perceptron = label_perceptron_calc.ax\nbias_subplot = ax_label_perceptron[2].twinx()",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "#init_weights",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "#init_weights = np.linspace(0.1,1.1,N)\ny_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)\nax_label_perceptron = label_perceptron_calc.ax\nbias_subplot = ax_label_perceptron[2].twinx()\nbias_subplot.plot(label_perceptron_calc.bias_history)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "y_label",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "y_label = np.random.randint(2, size=P)\nlabel_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)\nax_label_perceptron = label_perceptron_calc.ax\nbias_subplot = ax_label_perceptron[2].twinx()\nbias_subplot.plot(label_perceptron_calc.bias_history)\n#should we plot y target?",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "label_perceptron_calc",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "label_perceptron_calc = Calcitron(label_perceptron[r'$\\alpha$'], 0, label_perceptron[r'$\\gamma$'], label_perceptron[r'$\\delta$'], N)\nlabel_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)\nax_label_perceptron = label_perceptron_calc.ax\nbias_subplot = ax_label_perceptron[2].twinx()\nbias_subplot.plot(label_perceptron_calc.bias_history)\n#should we plot y target?\n#bias_subplot.set_ylim(min(label_perceptron_calc.bias_history)-0.01, max(label_perceptron_calc.bias_history)+0.01)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "label_perceptron_calc.weights",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "label_perceptron_calc.weights = init_weights_label.copy()\nlabel_perceptron_calc.train(local_inputs, target_perceptron_supervisor(y_label, eta_b = eta), protocol=fdc.modified_shouval_array,\n                            param_dict= label_perceptron_param_dict, plot = True, things_to_plot = plot_dict_label,\n                            include_z_in_output = False, no_firing=0)\nax_label_perceptron = label_perceptron_calc.ax\nbias_subplot = ax_label_perceptron[2].twinx()\nbias_subplot.plot(label_perceptron_calc.bias_history)\n#should we plot y target?\n#bias_subplot.set_ylim(min(label_perceptron_calc.bias_history)-0.01, max(label_perceptron_calc.bias_history)+0.01)\n#ax_label_perceptron[2].plot(label_perceptron_calc.bias_history,  color = \"g\")",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "ax_label_perceptron",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "ax_label_perceptron = label_perceptron_calc.ax\nbias_subplot = ax_label_perceptron[2].twinx()\nbias_subplot.plot(label_perceptron_calc.bias_history)\n#should we plot y target?\n#bias_subplot.set_ylim(min(label_perceptron_calc.bias_history)-0.01, max(label_perceptron_calc.bias_history)+0.01)\n#ax_label_perceptron[2].plot(label_perceptron_calc.bias_history,  color = \"g\")\nplt.subplots_adjust(left=0.08, right=0.9, top=0.926, bottom=0.11, wspace = 0.2, hspace = 0.357)\nplt.show()\neta_critic = 0.0003\ncritic_perceptron = {r'$\\alpha$':0.45, r'$\\delta$' + r'$Z_D$': 0.2, r'$\\delta$' + r'$Z_P$': 0.5, 'theta_d': 0.6, 'theta_p': 0.9}",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "bias_subplot",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "bias_subplot = ax_label_perceptron[2].twinx()\nbias_subplot.plot(label_perceptron_calc.bias_history)\n#should we plot y target?\n#bias_subplot.set_ylim(min(label_perceptron_calc.bias_history)-0.01, max(label_perceptron_calc.bias_history)+0.01)\n#ax_label_perceptron[2].plot(label_perceptron_calc.bias_history,  color = \"g\")\nplt.subplots_adjust(left=0.08, right=0.9, top=0.926, bottom=0.11, wspace = 0.2, hspace = 0.357)\nplt.show()\neta_critic = 0.0003\ncritic_perceptron = {r'$\\alpha$':0.45, r'$\\delta$' + r'$Z_D$': 0.2, r'$\\delta$' + r'$Z_P$': 0.5, 'theta_d': 0.6, 'theta_p': 0.9}\nf_d_critic = 0.7",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "eta_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "eta_critic = 0.0003\ncritic_perceptron = {r'$\\alpha$':0.45, r'$\\delta$' + r'$Z_D$': 0.2, r'$\\delta$' + r'$Z_P$': 0.5, 'theta_d': 0.6, 'theta_p': 0.9}\nf_d_critic = 0.7\nf_p_critic = 0.9\ntheta_d_critic = critic_perceptron['theta_d']\ntheta_p_critic = critic_perceptron['theta_p']\neta_dict_critic_perceptron= {(-np.inf,theta_d_critic):0, (theta_d_critic,theta_p_critic):eta_critic,\n                (theta_p_critic,np.inf):eta}\nFP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "critic_perceptron",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "critic_perceptron = {r'$\\alpha$':0.45, r'$\\delta$' + r'$Z_D$': 0.2, r'$\\delta$' + r'$Z_P$': 0.5, 'theta_d': 0.6, 'theta_p': 0.9}\nf_d_critic = 0.7\nf_p_critic = 0.9\ntheta_d_critic = critic_perceptron['theta_d']\ntheta_p_critic = critic_perceptron['theta_p']\neta_dict_critic_perceptron= {(-np.inf,theta_d_critic):0, (theta_d_critic,theta_p_critic):eta_critic,\n                (theta_p_critic,np.inf):eta}\nFP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}\ncritic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "f_d_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "f_d_critic = 0.7\nf_p_critic = 0.9\ntheta_d_critic = critic_perceptron['theta_d']\ntheta_p_critic = critic_perceptron['theta_p']\neta_dict_critic_perceptron= {(-np.inf,theta_d_critic):0, (theta_d_critic,theta_p_critic):eta_critic,\n                (theta_p_critic,np.inf):eta}\nFP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}\ncritic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}\nplot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "f_p_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "f_p_critic = 0.9\ntheta_d_critic = critic_perceptron['theta_d']\ntheta_p_critic = critic_perceptron['theta_p']\neta_dict_critic_perceptron= {(-np.inf,theta_d_critic):0, (theta_d_critic,theta_p_critic):eta_critic,\n                (theta_p_critic,np.inf):eta}\nFP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}\ncritic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}\nplot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN_critic = 100",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "theta_d_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "theta_d_critic = critic_perceptron['theta_d']\ntheta_p_critic = critic_perceptron['theta_p']\neta_dict_critic_perceptron= {(-np.inf,theta_d_critic):0, (theta_d_critic,theta_p_critic):eta_critic,\n                (theta_p_critic,np.inf):eta}\nFP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}\ncritic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}\nplot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN_critic = 100\nP_critic = 100",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "theta_p_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "theta_p_critic = critic_perceptron['theta_p']\neta_dict_critic_perceptron= {(-np.inf,theta_d_critic):0, (theta_d_critic,theta_p_critic):eta_critic,\n                (theta_p_critic,np.inf):eta}\nFP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}\ncritic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}\nplot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN_critic = 100\nP_critic = 100\ninit_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "FP_dict_critic_perceptron",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "FP_dict_critic_perceptron = {(-np.inf,theta_d):0.25, (theta_d,theta_p):f_d_critic,\n               (theta_p,np.inf):f_p_critic}\ncritic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}\nplot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN_critic = 100\nP_critic = 100\ninit_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)\ny = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "critic_perceptron_param_dict",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "critic_perceptron_param_dict = {\"eta_dict\":eta_dict_critic_perceptron, \"FP_dict\":FP_dict_critic_perceptron,\"soft_threshold\": 0}\nplot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN_critic = 100\nP_critic = 100\ninit_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)\ny = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "plot_dict_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "plot_dict_critic = [\"x\", \"weights\", \"output\", \"C_total\", \"Ca_bar_codes\"]\nN_critic = 100\nP_critic = 100\ninit_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)\ny = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "N_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "N_critic = 100\nP_critic = 100\ninit_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)\ny = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "P_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "P_critic = 100\ninit_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)\ny = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "init_weights_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "init_weights_critic = np.random.uniform(f_d_critic, f_p_critic+0.1, N_critic)\ny = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "y = np.random.randint(2, size=P_critic)\nZ_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "Z_d_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "Z_d_critic = 1\nZ_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)\n(critic_perceptron_calc.C_tot)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "Z_p_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "Z_p_critic = 2.5\ndelta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)\n(critic_perceptron_calc.C_tot)\n# ax_label_perceptron = label_perceptron_calc.ax",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "delta",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "delta = 0.2\nbias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)\n(critic_perceptron_calc.C_tot)\n# ax_label_perceptron = label_perceptron_calc.ax\n# bias_subplot = ax_label_perceptron[2].twinx()",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "bias_critic",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "bias_critic = -0.5 * ((N * f_d_critic) +(N * f_p_critic))\ncritic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)\n(critic_perceptron_calc.C_tot)\n# ax_label_perceptron = label_perceptron_calc.ax\n# bias_subplot = ax_label_perceptron[2].twinx()\n# bias_subplot.plot(label_perceptron_calc.bias_history)",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "critic_perceptron_calc",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "critic_perceptron_calc = Calcitron(critic_perceptron[r'$\\alpha$'],0, 0, delta, N_critic)\ncritic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)\n(critic_perceptron_calc.C_tot)\n# ax_label_perceptron = label_perceptron_calc.ax\n# bias_subplot = ax_label_perceptron[2].twinx()\n# bias_subplot.plot(label_perceptron_calc.bias_history)\nplt.show()",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "critic_perceptron_calc.weights",
        "kind": 5,
        "importPath": "perceptron _simulations",
        "description": "perceptron _simulations",
        "peekOfCode": "critic_perceptron_calc.weights = init_weights_critic.copy()\ncritic_perceptron_calc.train(local_inputs, critic_perceptron_supervisor(y,Z_d_critic,Z_p_critic), protocol=fdc.modified_shouval_array,\n                 param_dict= critic_perceptron_param_dict, plot = True, things_to_plot = plot_dict_critic,\n                 include_z_in_output = False, no_firing=0)\n(critic_perceptron_calc.C_tot)\n# ax_label_perceptron = label_perceptron_calc.ax\n# bias_subplot = ax_label_perceptron[2].twinx()\n# bias_subplot.plot(label_perceptron_calc.bias_history)\nplt.show()",
        "detail": "perceptron _simulations",
        "documentation": {}
    },
    {
        "label": "objective",
        "kind": 2,
        "importPath": "perceptron_optimizer",
        "description": "perceptron_optimizer",
        "peekOfCode": "def objective(trial, experiment, P, N, sparsity, n_iter, n_trials):\n    eta = trial.suggest_float('eta', 1e-6, 1e-1, log=True)\n    # experiment = Exp_Params(\"linear LUB 5\", \"linear\", 0, 5, eta=eta)\n    experiment.set_etas(eta)\n    FPs, TPs, FNs, TNs, pos, neg, acc_mean, acc_std = run_multiple_trials(experiment, P, N, sparsity, n_iter, n_trials)\n    # Invoke suggest methods of a Trial object to generate hyperparameters.\n    plt.figure(experiment.rule_name)\n    plt.plot(acc_mean, label='eta = ' + str(np.round(eta,5)))\n    plt.legend()\n    plt.show()",
        "detail": "perceptron_optimizer",
        "documentation": {}
    },
    {
        "label": "experiments",
        "kind": 5,
        "importPath": "perceptron_optimizer",
        "description": "perceptron_optimizer",
        "peekOfCode": "experiments = [Exp_Params(\"linear\", \"linear\", -np.nan, np.nan, eta=0.01),\n               Exp_Params(\"linear LB\", \"linear\", 0, np.nan, eta=0.01),\n               Exp_Params(\"FPLR 10\", \"linear\", 0, 10, eta=0.01),\n               Exp_Params(\"linear LUB 10\", \"linear\", 0, 10, eta=0.001),\n               Exp_Params(\"FPLR 1\", \"FPLR\", 0, 1, eta=0.025),  # optimized for p = 100 sparsity = 500\n               Exp_Params(\"linear LUB 1\", \"linear\", 0, 1, eta=0.001)\n               ]\n# experiments = [Exp_Params(\"linear LUB 5\", \"linear\", 0, 5), Exp_Params(\"FPLR 5\", \"FPLR\", 0, 5, eta=0.025)]\nbest_params_DF = pd.DataFrame(columns=['rule_name', 'eta', 'acc_mean'])\nfor experiment in experiments:",
        "detail": "perceptron_optimizer",
        "documentation": {}
    },
    {
        "label": "best_params_DF",
        "kind": 5,
        "importPath": "perceptron_optimizer",
        "description": "perceptron_optimizer",
        "peekOfCode": "best_params_DF = pd.DataFrame(columns=['rule_name', 'eta', 'acc_mean'])\nfor experiment in experiments:\n    obj_func = lambda trial: objective(trial, experiment, P=150, N=100, sparsity=0.5, n_iter=1000, n_trials=5)\n    # Pass func to Optuna studies\n    study = optuna.create_study(direction='minimize')\n    study.optimize(obj_func, n_trials=10)\n    best_params = study.best_params\n    best_params_DF = best_params_DF.append({'rule_name':experiment.rule_name,\n                                            'eta':best_params['eta'],\n                                            'score':study.best_value} ,ignore_index=True)",
        "detail": "perceptron_optimizer",
        "documentation": {}
    },
    {
        "label": "Perceptron_Calcitron",
        "kind": 6,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "class Perceptron_Calcitron(ClassifierMixin):\n    def __init__(self, experiment, n_iter=50):\n        self.experiment = experiment\n        self.classifier_name = experiment.classifier_type\n        eta_bias = experiment.eta_bias\n        self.n_iter = n_iter\n        rule_type = experiment.rule_type\n        eta_P = experiment.eta_P\n        eta_D = experiment.eta_D\n        fP = experiment.fP",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "Exp_Params",
        "kind": 6,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "class Exp_Params:\n    def __init__(self, rule_name, rule_type, fd, fp, eta = 0.0005, classifier_type = 'critic'):\n        self.classifier_type = 'critic'\n        self.rule_name = rule_name\n        self.rule_type = rule_type\n        self.fD = fd\n        self.fP = fp\n        self.set_etas(eta)\n        self.w_init = (self.fD+self.fP)/2\n        if np.isnan(self.w_init):",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "run_multiple_trials",
        "kind": 2,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "def run_multiple_trials(experiment, P, N, sparsity, n_iter, n_trials=10):\n    # Run multiple trials of the perceptron calcitron\n    # and return the learning curves\n    FPs = np.empty((n_trials, n_iter))\n    TPs = np.empty((n_trials, n_iter))\n    FNs = np.empty((n_trials, n_iter))\n    TNs = np.empty((n_trials, n_iter))\n    accs = np.empty((n_trials, n_iter))\n    for i in range(n_trials):\n        ('Trial: ', i)",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "run_experiments",
        "kind": 2,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "def run_experiments(experiments,\n                    P_values=[50, 100, 200], sparsity_values=[0.5], N=100, eta=0.1,\n                    n_iter=100, n_trials=2, *args,\n                    **kwargs):\n    # Create an empty dictionary to store the results\n    results_df = pd.DataFrame(columns=['rule_name', 'P', 'sparsity', 'accuracy', 'pos','neg'])\n    accuracy_list_df = pd.DataFrame(columns=['rule_name', 'P', 'sparsity', 'iter', 'accuracy', 'accuracy_STD'])\n    # Loop through the rule names\n    for sparsity in sparsity_values:\n        for P in P_values:",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "dashboard",
        "kind": 2,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "def dashboard():\n    plt.close('all')\n#    fig, ax = plt.subplots(nrows=4, ncols=4)\n    results_df = pd.read_csv(constants.DATA_FOLDER + \"perceptron_results.csv\")\n    accuracy_list_df = pd.read_csv(constants.DATA_FOLDER + \"perceptron_accuracy_list.csv\")\n    # Plot the lines on two facets\n    sns.relplot(\n        data=accuracy_list_df, x=\"iter\", y=\"accuracy\",\n        hue=\"rule_name\", col=\"sparsity\", row=\"P\",\n        kind=\"line\", facet_kws=dict(sharex=True, sharey=True)",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "TINY_SIZE",
        "kind": 5,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "TINY_SIZE = 6\nSMALL_SIZE = 8\nMEDIUM_SIZE = 10\nBIGGER_SIZE = 10\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=TINY_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=SMALL_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=TINY_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=SMALL_SIZE)  # legend fontsize",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "SMALL_SIZE",
        "kind": 5,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "SMALL_SIZE = 8\nMEDIUM_SIZE = 10\nBIGGER_SIZE = 10\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=TINY_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=SMALL_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=TINY_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=SMALL_SIZE)  # legend fontsize\nplt.rc('figure', titlesize=SMALL_SIZE)  # fontsize of the figure title",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "MEDIUM_SIZE",
        "kind": 5,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "MEDIUM_SIZE = 10\nBIGGER_SIZE = 10\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=TINY_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=SMALL_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=TINY_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=SMALL_SIZE)  # legend fontsize\nplt.rc('figure', titlesize=SMALL_SIZE)  # fontsize of the figure title\nclass Perceptron_Calcitron(ClassifierMixin):",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "BIGGER_SIZE",
        "kind": 5,
        "importPath": "percep_perform",
        "description": "percep_perform",
        "peekOfCode": "BIGGER_SIZE = 10\nplt.rc('font', size=SMALL_SIZE)  # controls default text sizes\nplt.rc('axes', titlesize=TINY_SIZE)  # fontsize of the axes title\nplt.rc('axes', labelsize=SMALL_SIZE)  # fontsize of the x and y labels\nplt.rc('xtick', labelsize=TINY_SIZE)  # fontsize of the tick labels\nplt.rc('ytick', labelsize=SMALL_SIZE)  # fontsize of the tick labels\nplt.rc('legend', fontsize=SMALL_SIZE)  # legend fontsize\nplt.rc('figure', titlesize=SMALL_SIZE)  # fontsize of the figure title\nclass Perceptron_Calcitron(ClassifierMixin):\n    def __init__(self, experiment, n_iter=50):",
        "detail": "percep_perform",
        "documentation": {}
    },
    {
        "label": "Region",
        "kind": 6,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "class Region:\n    def __init__(self, name, bounds, fp, eta, fp_color = None, bar_code_color = None):\n        self.name = name\n        self.bounds = bounds\n        self.fp = fp\n        self.eta = eta\n        self.fp_color = fp_color\n        self.bar_code_color = bar_code_color\n        if self.fp_color is None:\n            if self.name in default_fp_colors.keys():",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "Plasticity_Rule",
        "kind": 6,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "class Plasticity_Rule:\n    def __init__(self, regions, rule='FPLR'):\n        self.rule = rule\n        self.regions = sorted(regions, key=lambda region: region.bounds[0])\n        self.region_names = [region.name for region in self.regions]\n        self.fps = [region.fp for region in self.regions]\n        self.thetas = [region.bounds[0] for region in self.regions[1:]]\n        self.etas = [region.eta for region in self.regions]\n        self.theta_names = [r'$\\theta_{' + region.name + '}$' for region in self.regions[1:]]\n        self.eta_names = [r'$\\eta_{' + region.name + '}$' for region in self.regions[1:]]",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "step_function",
        "kind": 2,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "def step_function(x, thresholds, heights, theta_0=0):\n    thetas = [theta_0] + thresholds  # append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:]  # sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype=float)[sort_inds]  # maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])\n                * np.heaviside(x - sorted_thresholds[it], 0)\n                for it in range(len(sorted_thresholds))]) + \\\n           sorted_heights[0]\ndef sym_log(x):",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "sym_log",
        "kind": 2,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "def sym_log(x):\n    x_norm = np.sign(x) * np.log10(abs(x) + 1)\n    return x_norm\ndef quiver_norm(x):\n    min_arrow_length = 4\n    max_arrow_length = 5\n    x_new = x\n    x_new[np.abs(np.round(x, decimals=10)) == 0] = np.nan\n    logs = np.log(np.abs(x_new))\n    return np.sign(x) * (np.log10(1 + abs(x) / (10 ** -3)))",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "quiver_norm",
        "kind": 2,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "def quiver_norm(x):\n    min_arrow_length = 4\n    max_arrow_length = 5\n    x_new = x\n    x_new[np.abs(np.round(x, decimals=10)) == 0] = np.nan\n    logs = np.log(np.abs(x_new))\n    return np.sign(x) * (np.log10(1 + abs(x) / (10 ** -3)))\ndef phase_plane(matrix_for_plot, x, y, ss_x=20, ss_y=10, norm=SymLogNorm(linthresh=10 ** -3), ax=None):\n    X1, Y1 = np.meshgrid(x, y)  # create 2 matrices\n    U = np.zeros_like(matrix_for_plot)",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "phase_plane",
        "kind": 2,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "def phase_plane(matrix_for_plot, x, y, ss_x=20, ss_y=10, norm=SymLogNorm(linthresh=10 ** -3), ax=None):\n    X1, Y1 = np.meshgrid(x, y)  # create 2 matrices\n    U = np.zeros_like(matrix_for_plot)\n    V = np.array(matrix_for_plot)\n    arrow_start_x = 15\n    arrow_start_y = 0\n    V1 = quiver_norm(V[arrow_start_x::ss_x, arrow_start_y::ss_y])\n    ax.quiver(X1[arrow_start_x::ss_x, arrow_start_y::ss_y], Y1[arrow_start_x::ss_x, arrow_start_y::ss_y],\n              U[arrow_start_x::ss_x, arrow_start_y::ss_y], V1, width=0.02)\ndef calcium_step(height, delay_dur=canonical_delay_dur, stim_duration=canonical_stim_dur, end_dur=canonical_end_dur):",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "calcium_step",
        "kind": 2,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "def calcium_step(height, delay_dur=canonical_delay_dur, stim_duration=canonical_stim_dur, end_dur=canonical_end_dur):\n    return [0 for it in range(delay_dur)] + [height for it in range(stim_duration)] + [0 for it in range(end_dur)]\nclass Region:\n    def __init__(self, name, bounds, fp, eta, fp_color = None, bar_code_color = None):\n        self.name = name\n        self.bounds = bounds\n        self.fp = fp\n        self.eta = eta\n        self.fp_color = fp_color\n        self.bar_code_color = bar_code_color",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "rule_from_regions",
        "kind": 2,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "def rule_from_regions(eta_dict, fp_dict, name_dict):\n    regions = []\n    for name, bounds in name_dict.items():\n        eta = eta_dict[bounds]\n        fp = fp_dict[bounds]\n        region = Region(name, bounds, fp, eta)\n        regions.append(region)\n    return Plasticity_Rule(regions)\nclass Plasticity_Rule:\n    def __init__(self, regions, rule='FPLR'):",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "canonical_delay_dur",
        "kind": 5,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "canonical_delay_dur = 5\ncanonical_stim_dur = 30\ncanonical_end_dur = 30\ndefault_fp_colors = {\"P\":'r', \"D\":'b', 'N':'k'}\ndefault_bc_colors = {\"P\": 'r', \"D\": 'b', 'N': 'w'}\ndef step_function(x, thresholds, heights, theta_0=0):\n    thetas = [theta_0] + thresholds  # append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:]  # sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype=float)[sort_inds]  # maintain consistency of height with sort indices",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "canonical_stim_dur",
        "kind": 5,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "canonical_stim_dur = 30\ncanonical_end_dur = 30\ndefault_fp_colors = {\"P\":'r', \"D\":'b', 'N':'k'}\ndefault_bc_colors = {\"P\": 'r', \"D\": 'b', 'N': 'w'}\ndef step_function(x, thresholds, heights, theta_0=0):\n    thetas = [theta_0] + thresholds  # append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:]  # sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype=float)[sort_inds]  # maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "canonical_end_dur",
        "kind": 5,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "canonical_end_dur = 30\ndefault_fp_colors = {\"P\":'r', \"D\":'b', 'N':'k'}\ndefault_bc_colors = {\"P\": 'r', \"D\": 'b', 'N': 'w'}\ndef step_function(x, thresholds, heights, theta_0=0):\n    thetas = [theta_0] + thresholds  # append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:]  # sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype=float)[sort_inds]  # maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])\n                * np.heaviside(x - sorted_thresholds[it], 0)",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "default_fp_colors",
        "kind": 5,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "default_fp_colors = {\"P\":'r', \"D\":'b', 'N':'k'}\ndefault_bc_colors = {\"P\": 'r', \"D\": 'b', 'N': 'w'}\ndef step_function(x, thresholds, heights, theta_0=0):\n    thetas = [theta_0] + thresholds  # append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:]  # sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype=float)[sort_inds]  # maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])\n                * np.heaviside(x - sorted_thresholds[it], 0)\n                for it in range(len(sorted_thresholds))]) + \\",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "default_bc_colors",
        "kind": 5,
        "importPath": "plasticity_rule",
        "description": "plasticity_rule",
        "peekOfCode": "default_bc_colors = {\"P\": 'r', \"D\": 'b', 'N': 'w'}\ndef step_function(x, thresholds, heights, theta_0=0):\n    thetas = [theta_0] + thresholds  # append the zero threshold\n    sort_inds = np.argsort(thetas)\n    sorted_thresholds = np.array(thetas)[sort_inds][1:]  # sort both the thresholds by height\n    sorted_heights = np.array(heights, dtype=float)[sort_inds]  # maintain consistency of height with sort indices\n    return sum([(sorted_heights[it + 1] - sorted_heights[it])\n                * np.heaviside(x - sorted_thresholds[it], 0)\n                for it in range(len(sorted_thresholds))]) + \\\n           sorted_heights[0]",
        "detail": "plasticity_rule",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "plotting_calcitron",
        "description": "plotting_calcitron",
        "peekOfCode": "def load_json(file_name):\n    with open(file_name, 'r', encoding='utf-8') as f:\n        loaded_dict = json.load(f)\n    loaded_dict[\"param_dict\"] = eval(loaded_dict[\"param_dict\"].replace(\"inf\", \"np.inf\"))\n    return loaded_dict\ndef plot_accuracy(file_name):\n    data = load_json(file_name)\n    accuracies = data[\"accuracy_list\"]\n    plt.plot(accuracies)\nplot_accuracy(r'CapacityPerceptron_Calcitron/modified_shouval_array_linear/P_200N_100num_epochs_10.json')",
        "detail": "plotting_calcitron",
        "documentation": {}
    },
    {
        "label": "plot_accuracy",
        "kind": 2,
        "importPath": "plotting_calcitron",
        "description": "plotting_calcitron",
        "peekOfCode": "def plot_accuracy(file_name):\n    data = load_json(file_name)\n    accuracies = data[\"accuracy_list\"]\n    plt.plot(accuracies)\nplot_accuracy(r'CapacityPerceptron_Calcitron/modified_shouval_array_linear/P_200N_100num_epochs_10.json')\nplt.show()",
        "detail": "plotting_calcitron",
        "documentation": {}
    },
    {
        "label": "label_panels",
        "kind": 2,
        "importPath": "plot_helpers",
        "description": "plot_helpers",
        "peekOfCode": "def label_panels(fig, labels = None, xloc=0, yloc=1.0, size=constants.PANEL_LABEL_SIZE):\n    if labels is None:\n        labels = [str(x) for x in range(len(fig.axes))]\n    for n in range(len(labels)):\n        # label physical distance to the left and up:\n            ax = fig.axes[n]\n            trans = transforms.ScaledTranslation(-20 / 72, 7 / 72, fig.dpi_scale_trans)\n            ax.text(xloc, yloc, labels[n], transform=ax.transAxes + trans,\n                    fontsize=size, va='bottom')\ndef label_panels_mosaic(fig, axes, xloc = 0, yloc = 1.0, size = 20):",
        "detail": "plot_helpers",
        "documentation": {}
    },
    {
        "label": "label_panels_mosaic",
        "kind": 2,
        "importPath": "plot_helpers",
        "description": "plot_helpers",
        "peekOfCode": "def label_panels_mosaic(fig, axes, xloc = 0, yloc = 1.0, size = 20):\n    for key in axes.keys():\n    # label physical distance to the left and up:\n        ax = axes[key]\n        trans = transforms.ScaledTranslation(-20/72, 7/72, fig.dpi_scale_trans)\n        ax.text(xloc, yloc, key, transform=ax.transAxes + trans,\n                fontsize=size, va='bottom')\ndef share_axes(subplot_array, sharex, sharey, delete_row_ticklabels = 1, delete_col_ticklabels = 1, delete_x_labels = 1, delete_y_labels = 1, one_d_row = True):\n    shape_orig = np.array(subplot_array).shape\n    subplot_array = np.atleast_2d(subplot_array)",
        "detail": "plot_helpers",
        "documentation": {}
    },
    {
        "label": "share_axes",
        "kind": 2,
        "importPath": "plot_helpers",
        "description": "plot_helpers",
        "peekOfCode": "def share_axes(subplot_array, sharex, sharey, delete_row_ticklabels = 1, delete_col_ticklabels = 1, delete_x_labels = 1, delete_y_labels = 1, one_d_row = True):\n    shape_orig = np.array(subplot_array).shape\n    subplot_array = np.atleast_2d(subplot_array)\n    if len(shape_orig)==1 and one_d_row: #if it's a 1d array and we want it to be a row\n        subplot_array = subplot_array.T #transpose it\n    shape = subplot_array.shape\n    for i in range(shape[0]):\n        for j in range(shape[1]):\n            ax = subplot_array[i,j]\n            if sharex in ('rows', 'both'):",
        "detail": "plot_helpers",
        "documentation": {}
    },
    {
        "label": "SAVE_FOLDER",
        "kind": 5,
        "importPath": "plot_helpers",
        "description": "plot_helpers",
        "peekOfCode": "SAVE_FOLDER = 'Calc_Plots\\\\'\ndef label_panels(fig, labels = None, xloc=0, yloc=1.0, size=constants.PANEL_LABEL_SIZE):\n    if labels is None:\n        labels = [str(x) for x in range(len(fig.axes))]\n    for n in range(len(labels)):\n        # label physical distance to the left and up:\n            ax = fig.axes[n]\n            trans = transforms.ScaledTranslation(-20 / 72, 7 / 72, fig.dpi_scale_trans)\n            ax.text(xloc, yloc, labels[n], transform=ax.transAxes + trans,\n                    fontsize=size, va='bottom')",
        "detail": "plot_helpers",
        "documentation": {}
    },
    {
        "label": "rule_comparison_grid",
        "kind": 2,
        "importPath": "rule_comparison_grid",
        "description": "rule_comparison_grid",
        "peekOfCode": "def rule_comparison_grid(calcitrons, rule_names, all_bar_mats, bar_names, all_inputs, coeffs_to_use=[0, 1, 2, 3],\n                         plot_cbar=[], show_supervisor=0, w_init='middle', figsize = None):\n    num_rules = len(calcitrons)\n    for i,calc in enumerate(calcitrons):\n        calc.w_init = w_init\n        calc.train(all_inputs[i])\n    max_calcium = max([np.max(calc.C_tot) for calc in calcitrons])\n    all_rules = [calcitron.plasticity_rule for calcitron in calcitrons]\n    all_coeffs = [calcitron.coeffs for calcitron in calcitrons]\n    num_rows = 6 + int(show_supervisor)  # if there's a supervior, add another row",
        "detail": "rule_comparison_grid",
        "documentation": {}
    },
    {
        "label": "python_executable",
        "kind": 5,
        "importPath": "Run_all_figs",
        "description": "Run_all_figs",
        "peekOfCode": "python_executable = sys.executable\n# Use glob to get a list of files that match the pattern \"Fig*.py\"\nfile_list = glob.glob(\"Fig*.py\")\n# Iterate over the list of files\nfor file in file_list:\n    print(str(file))\n    subprocess.run([python_executable, '-B', '-u', file])\n    plt.close('all')\nparam_helpers.param_concat()",
        "detail": "Run_all_figs",
        "documentation": {}
    },
    {
        "label": "file_list",
        "kind": 5,
        "importPath": "Run_all_figs",
        "description": "Run_all_figs",
        "peekOfCode": "file_list = glob.glob(\"Fig*.py\")\n# Iterate over the list of files\nfor file in file_list:\n    print(str(file))\n    subprocess.run([python_executable, '-B', '-u', file])\n    plt.close('all')\nparam_helpers.param_concat()",
        "detail": "Run_all_figs",
        "documentation": {}
    },
    {
        "label": "Supervisor",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class Supervisor:\n    def __init__(self):\n        self.Z_p = 0\n        self.Z_d = 0\n        self.Z = 0\n        self.eta_b = 0\n        pass\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        pass\n    def delta_bias(self, pattern, pattern_index, y_hat_binary, y_hat):",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "null_supervisor",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class null_supervisor(Supervisor):\n    def __init__(self):\n        super().__init__()\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        if y_hat_binary == 1:\n            label = 'TP'\n        else: label = 'TN'\n        return 0, label #returns Z, +1 for fp, -1 for fn, 0 for correct\nclass signal_noise_supervisor(Supervisor):\n    def __init__(self, signals):",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "signal_noise_supervisor",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class signal_noise_supervisor(Supervisor):\n    def __init__(self, signals):\n        super().__init__()\n        self.signals = np.atleast_2d(signals)\n        self.Z = 0\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        target = np.any(np.all(pattern == self.signals, axis=1))\n        if y_hat_binary == 1:\n            if target:\n                label = 'TP'",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "one_shot_flip_flop_supervisor",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class one_shot_flip_flop_supervisor(Supervisor):\n    def __init__(self, y):\n        super().__init__()\n        self.y = y\n        self.Z = 1\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        if y_hat_binary == 1:\n            label = 'TP'\n        else:\n            label = 'TN'",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "target_perceptron_supervisor",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class target_perceptron_supervisor(Supervisor):\n    def __init__(self, Zp = 0.3, X = None, y = None, eta_b = 0):\n        super().__init__()\n        self.eta_b = eta_b\n        self.Z_p = Zp\n        if not X is None:\n            self.label_map = make_label_map(X, y)\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        target = self.label_map[tuple(pattern)]\n        if y_hat_binary == 1:",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "critic_perceptron_supervisor",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class critic_perceptron_supervisor(Supervisor):\n    def __init__(self, Z_d = 0.2, Z_p = 0.5, X = None, y = None, eta_b=0):\n        super().__init__()\n        self.Z_d = Z_d\n        self.Z_p = Z_p\n        self.eta_b = eta_b\n        if not X is None:\n            self.label_map = make_label_map(X, y)\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        target = self.label_map[tuple(pattern)]",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "homeostatic_supervisorPD",
        "kind": 6,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "class homeostatic_supervisorPD(Supervisor):\n    def __init__(self, min_target, max_target, Z_d, Z_p):\n        super().__init__()\n        self.min_target = min_target\n        self.max_target = max_target\n        self.Z_d = Z_d\n        self.Z_p = Z_p\n    def supervise(self, pattern_index, pattern, y_hat_binary, y_hat):\n        if y_hat > self.max_target:\n            return self.Z_d, 'H'",
        "detail": "supervisors",
        "documentation": {}
    },
    {
        "label": "make_label_map",
        "kind": 2,
        "importPath": "supervisors",
        "description": "supervisors",
        "peekOfCode": "def make_label_map(X,y):\n    X = np.atleast_2d(X)\n    label_map = {tuple(X[i]): y[i] for i in range(X.shape[0])}\n    return label_map\nclass Supervisor:\n    def __init__(self):\n        self.Z_p = 0\n        self.Z_d = 0\n        self.Z = 0\n        self.eta_b = 0",
        "detail": "supervisors",
        "documentation": {}
    }
]